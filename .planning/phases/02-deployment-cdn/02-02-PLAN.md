---
phase: 02-deployment-cdn
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/functions/deploy-handler/index.ts
  - infra/deployment.ts
  - infra/build-pipeline.ts
  - buildspecs/nextjs-build.yml
autonomous: true

must_haves:
  truths:
    - "Build artifacts are deployed to Lambda after CodeBuild succeeds"
    - "Lambda versions are published for each deployment"
    - "Static assets are uploaded to S3 with correct cache headers"
    - "CloudFront origin is updated to new Lambda version"
    - "Deployment record is updated with version ARNs"
  artifacts:
    - path: "packages/functions/deploy-handler/index.ts"
      provides: "Deployment orchestration Lambda"
      exports: ["handler"]
    - path: "infra/deployment.ts"
      provides: "Deploy handler Lambda definition"
      contains: "deployHandler"
  key_links:
    - from: "packages/functions/deploy-handler/index.ts"
      to: "Lambda API"
      via: "@aws-sdk/client-lambda publishVersion"
      pattern: "publishVersion"
    - from: "packages/functions/deploy-handler/index.ts"
      to: "S3 API"
      via: "@aws-sdk/client-s3 putObject"
      pattern: "PutObjectCommand"
    - from: "CodeBuild post_build"
      to: "deploy-handler Lambda"
      via: "Lambda invoke"
      pattern: "aws lambda invoke"
---

<objective>
Create the deployment orchestrator that processes OpenNext build artifacts and deploys them to Lambda + S3 + CloudFront.

Purpose: This Lambda takes completed build artifacts from CodeBuild, uploads static assets to S3, updates Lambda function code, publishes a new Lambda version, and updates the deployment record with version ARNs for rollback capability.

Output: Working deployment flow where CodeBuild completion triggers deployment, and the site becomes accessible via CloudFront.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deployment-cdn/02-RESEARCH.md
@.planning/phases/02-deployment-cdn/02-01-SUMMARY.md

# Existing infrastructure
@infra/deployment.ts
@infra/build-pipeline.ts
@packages/functions/build-orchestrator/index.ts
@packages/core/schemas/deployment.ts
@packages/core/db/deployments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deploy-handler Lambda</name>
  <files>packages/functions/deploy-handler/index.ts</files>
  <action>
Create the deployment orchestrator Lambda that processes build artifacts:

**Input (from CodeBuild or direct invocation):**
```typescript
interface DeployEvent {
  deploymentId: string;
  projectId: string;
  artifactPath: string; // s3://bucket/artifacts/projectId/commitSha/
}
```

**Deployment Flow:**

1. **Fetch deployment record** from DynamoDB to get metadata

2. **Download and extract OpenNext artifacts** from S3:
   - `.open-next/server-function/` -> Server Lambda code
   - `.open-next/image-optimization-function/` -> Image Lambda code
   - `.open-next/assets/` -> Static assets for S3

3. **Upload static assets to S3**:
   - Upload to staticAssetsBucket under `deployments/{deploymentId}/`
   - Set Cache-Control headers per file type:
     - `/_next/static/*`: `public,max-age=31536000,immutable`
     - Other assets: `public,max-age=0,must-revalidate`
   - Use streaming upload for large files

4. **Update Server Lambda function code**:
   ```typescript
   const updateResult = await lambda.updateFunctionCode({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     S3Bucket: artifactBucket,
     S3Key: `${artifactPath}/server-function.zip`,
   });
   ```

5. **Wait for Lambda update to complete**:
   ```typescript
   await lambda.waitUntilFunctionUpdated({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
   });
   ```

6. **Publish new Lambda version** (immutable for rollback):
   ```typescript
   const version = await lambda.publishVersion({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     Description: `Deployment ${deploymentId}`,
   });
   // version.Version is the version number
   // version.FunctionArn is the versioned ARN
   ```

7. **Update Image Lambda** (same process):
   - Update code, wait, publish version

8. **Update deployment record** in DynamoDB:
   ```typescript
   await setDeploymentVersion(deploymentId, {
     lambdaServerVersionArn: serverVersion.FunctionArn,
     lambdaImageVersionArn: imageVersion.FunctionArn,
     staticAssetsPath: `s3://${staticAssetsBucket}/deployments/${deploymentId}/`,
     deployedAt: Date.now(),
     version: `v${Date.now()}`,
     status: 'deployed',
   });
   ```

9. **Update CloudFront (optional for v1)**:
   - For v1, we can skip CloudFront origin update since we're using Lambda function URLs
   - CloudFront automatically uses the latest function code
   - Note: For true zero-downtime with versioned ARNs, we'd need Lambda@Edge or CloudFront continuous deployment

**Environment variables needed:**
- SERVER_FUNCTION_NAME
- IMAGE_FUNCTION_NAME
- STATIC_ASSETS_BUCKET
- DEPLOYMENTS_TABLE
- ARTIFACTS_BUCKET

**Error handling:**
- If any step fails, update deployment status to 'deploy_failed'
- Log detailed error for debugging
- Do NOT delete old Lambda versions (needed for rollback)

**AWS SDK imports:**
```typescript
import { LambdaClient, UpdateFunctionCodeCommand, PublishVersionCommand, waitUntilFunctionUpdated } from '@aws-sdk/client-lambda';
import { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Deploy handler Lambda created with full deployment flow: artifact download, S3 upload, Lambda update, version publishing, and DynamoDB update.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deploy-handler to infrastructure and update CodeBuild</name>
  <files>infra/deployment.ts, infra/build-pipeline.ts, buildspecs/nextjs-build.yml</files>
  <action>
**Part A: Add deploy-handler Lambda to infra/deployment.ts**

```typescript
// Deploy handler Lambda - triggered after CodeBuild completes
export const deployHandler = new sst.aws.Function("DeployHandler", {
  handler: "packages/functions/deploy-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "5 minutes", // Deployment can take time
  memory: "512 MB",
  environment: {
    SERVER_FUNCTION_NAME: serverFunction.name,
    IMAGE_FUNCTION_NAME: imageFunction.name,
    STATIC_ASSETS_BUCKET: staticAssetsBucket.name,
  },
  link: [deploymentsTable, artifactsBucket, staticAssetsBucket],
  permissions: [
    // Lambda permissions for updating function code and publishing versions
    {
      actions: [
        "lambda:UpdateFunctionCode",
        "lambda:PublishVersion",
        "lambda:GetFunction",
        "lambda:GetFunctionConfiguration",
      ],
      resources: [
        serverFunction.arn,
        imageFunction.arn,
        // Include versioned ARNs pattern
        `${serverFunction.arn}:*`,
        `${imageFunction.arn}:*`,
      ],
    },
  ],
});
```

**Part B: Update CodeBuild post_build phase (infra/build-pipeline.ts)**

Modify the embedded buildspec to invoke deploy-handler after successful build:

In the `post_build` phase, add:
```yaml
# After uploading artifacts to S3, trigger deployment
- |
  aws lambda invoke \
    --function-name $DEPLOY_HANDLER_NAME \
    --invocation-type Event \
    --cli-binary-format raw-in-base64-out \
    --payload "{\"deploymentId\":\"$DEPLOYMENT_ID\",\"projectId\":\"$PROJECT_ID\",\"artifactPath\":\"$ARTIFACT_PATH\"}" \
    /dev/null
```

Add environment variable to CodeBuild:
```typescript
environmentVariables: [
  // ... existing vars
  {
    name: "DEPLOY_HANDLER_NAME",
    value: deployHandler.name, // Reference from deployment.ts
  },
],
```

**Part C: Grant CodeBuild permission to invoke deploy-handler**

Add IAM policy to CodeBuild role:
```typescript
{
  actions: ["lambda:InvokeFunction"],
  resources: [deployHandler.arn],
}
```

**Import order in sst.config.ts:**
Since build-pipeline.ts needs deployHandler from deployment.ts, ensure deployment.ts is imported before build-pipeline.ts.
  </action>
  <verify>
Deploy and test:
```bash
npx sst dev
# Verify deploy handler Lambda exists
# Verify CodeBuild project has DEPLOY_HANDLER_NAME env var
```
  </verify>
  <done>
Deploy handler Lambda integrated into infrastructure. CodeBuild post_build triggers deployment after successful build.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx sst dev` deploys without errors
2. Deploy handler Lambda exists with correct permissions
3. CodeBuild project includes DEPLOY_HANDLER_NAME environment variable
4. Manual test: Trigger a build and verify deployment flow:
   - Build completes
   - Deploy handler is invoked
   - Lambda code is updated
   - Lambda version is published
   - Deployment record updated with version ARN
</verification>

<success_criteria>
- Deploy handler Lambda processes build artifacts correctly
- Lambda function code updates and version publishing works
- Static assets uploaded to S3 with correct cache headers
- Deployment record updated with Lambda version ARNs
- CodeBuild triggers deployment after successful build
- Zero-downtime achieved (new Lambda version, not in-place update of $LATEST)
</success_criteria>

<output>
After completion, create `.planning/phases/02-deployment-cdn/02-02-SUMMARY.md`
</output>
