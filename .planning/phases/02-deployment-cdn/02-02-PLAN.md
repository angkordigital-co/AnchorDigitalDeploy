---
phase: 02-deployment-cdn
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/functions/deploy-handler/index.ts
  - infra/deployment.ts
  - infra/build-pipeline.ts
  - buildspecs/nextjs-build.yml
autonomous: true

must_haves:
  truths:
    - "Build artifacts are deployed to Lambda after CodeBuild succeeds"
    - "Lambda versions are published for each deployment"
    - "Static assets are uploaded to S3 with correct cache headers"
    - "CloudFront origin is updated to new Lambda version"
    - "Deployment record is updated with version ARNs"
    - "Traffic shifts to new version without request failures"
  artifacts:
    - path: "packages/functions/deploy-handler/index.ts"
      provides: "Deployment orchestration Lambda"
      exports: ["handler"]
    - path: "infra/deployment.ts"
      provides: "Deploy handler Lambda definition"
      contains: "deployHandler"
  key_links:
    - from: "packages/functions/deploy-handler/index.ts"
      to: "Lambda API"
      via: "@aws-sdk/client-lambda publishVersion + updateAlias"
      pattern: "UpdateAliasCommand"
    - from: "packages/functions/deploy-handler/index.ts"
      to: "S3 API"
      via: "@aws-sdk/client-s3 putObject"
      pattern: "PutObjectCommand"
    - from: "CodeBuild post_build"
      to: "deploy-handler Lambda"
      via: "Lambda invoke"
      pattern: "aws lambda invoke"
---

<objective>
Create the deployment orchestrator that processes OpenNext build artifacts and deploys them to Lambda + S3 + CloudFront with zero-downtime traffic shifting.

Purpose: This Lambda takes completed build artifacts from CodeBuild, uploads static assets to S3, updates Lambda function code, publishes a new Lambda version, and atomically shifts traffic via Lambda aliases for zero-downtime deployment (DEPLOY-04).

Output: Working deployment flow where CodeBuild completion triggers deployment, and the site becomes accessible via CloudFront without request failures during transition.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deployment-cdn/02-RESEARCH.md
@.planning/phases/02-deployment-cdn/02-01-SUMMARY.md

# Existing infrastructure
@infra/deployment.ts
@infra/build-pipeline.ts
@packages/functions/build-orchestrator/index.ts
@packages/core/schemas/deployment.ts
@packages/core/db/deployments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deploy-handler Lambda with zero-downtime alias routing</name>
  <files>packages/functions/deploy-handler/index.ts</files>
  <action>
Create the deployment orchestrator Lambda that processes build artifacts with zero-downtime deployment:

**Input (from CodeBuild or direct invocation):**
```typescript
interface DeployEvent {
  deploymentId: string;
  projectId: string;
  artifactPath: string; // s3://bucket/artifacts/projectId/commitSha/
}
```

**Zero-Downtime Deployment Flow (DEPLOY-04):**

1. **Fetch deployment record** from DynamoDB to get metadata

2. **Download and extract OpenNext artifacts** from S3:
   - `.open-next/server-function/` -> Server Lambda code
   - `.open-next/image-optimization-function/` -> Image Lambda code
   - `.open-next/assets/` -> Static assets for S3

3. **Upload static assets to S3**:
   - Upload to staticAssetsBucket under `deployments/{deploymentId}/`
   - Set Cache-Control headers per file type:
     - `/_next/static/*`: `public,max-age=31536000,immutable`
     - Other assets: `public,max-age=0,must-revalidate`
   - Use streaming upload for large files

4. **Update Server Lambda function code**:
   ```typescript
   const updateResult = await lambda.updateFunctionCode({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     S3Bucket: artifactBucket,
     S3Key: `${artifactPath}/server-function.zip`,
   });
   ```

5. **Wait for Lambda update to complete**:
   ```typescript
   await waitUntilFunctionUpdated({
     client: lambda,
     maxWaitTime: 300,
   }, {
     FunctionName: process.env.SERVER_FUNCTION_NAME,
   });
   ```

6. **Publish new Lambda version** (immutable for rollback):
   ```typescript
   const version = await lambda.send(new PublishVersionCommand({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     Description: `Deployment ${deploymentId}`,
   }));
   // version.Version is the version number
   // version.FunctionArn is the versioned ARN
   ```

7. **ZERO-DOWNTIME: Update Lambda alias to point to new version**:
   This is the critical step for zero-downtime deployment. Lambda aliases provide atomic traffic shifting.

   ```typescript
   import { UpdateAliasCommand, CreateAliasCommand, GetAliasCommand } from '@aws-sdk/client-lambda';

   const LIVE_ALIAS = 'live'; // CloudFront/Function URL points to this alias

   try {
     // Try to update existing alias
     await lambda.send(new UpdateAliasCommand({
       FunctionName: process.env.SERVER_FUNCTION_NAME,
       Name: LIVE_ALIAS,
       FunctionVersion: version.Version,
       Description: `Deployment ${deploymentId} - ${new Date().toISOString()}`,
     }));
   } catch (error) {
     if (error.name === 'ResourceNotFoundException') {
       // Create alias if it doesn't exist (first deployment)
       await lambda.send(new CreateAliasCommand({
         FunctionName: process.env.SERVER_FUNCTION_NAME,
         Name: LIVE_ALIAS,
         FunctionVersion: version.Version,
         Description: `Deployment ${deploymentId} - ${new Date().toISOString()}`,
       }));
     } else {
       throw error;
     }
   }
   ```

   **Why aliases provide zero-downtime:**
   - CloudFront/Function URL is configured to invoke `function:live` (the alias)
   - Updating an alias is an atomic operation
   - No requests hit $LATEST during code upload
   - Traffic instantly shifts from old version to new version
   - Old version remains available for rollback

8. **Update Image Lambda** (same process):
   - Update code, wait, publish version, update alias

9. **Update deployment record** in DynamoDB:
   ```typescript
   await setDeploymentVersion(deploymentId, {
     lambdaServerVersionArn: `${serverFunctionArn}:${version.Version}`,
     lambdaImageVersionArn: `${imageFunctionArn}:${imageVersion.Version}`,
     lambdaServerAliasArn: `${serverFunctionArn}:${LIVE_ALIAS}`,
     staticAssetsPath: `s3://${staticAssetsBucket}/deployments/${deploymentId}/`,
     deployedAt: Date.now(),
     version: `v${Date.now()}`,
     status: 'deployed',
   });
   ```

**Environment variables needed:**
- SERVER_FUNCTION_NAME
- IMAGE_FUNCTION_NAME
- STATIC_ASSETS_BUCKET
- DEPLOYMENTS_TABLE
- ARTIFACTS_BUCKET

**Error handling:**
- If any step fails, update deployment status to 'deploy_failed'
- Log detailed error for debugging
- Do NOT delete old Lambda versions (needed for rollback)
- If alias update fails, the new version still exists for manual recovery

**AWS SDK imports:**
```typescript
import {
  LambdaClient,
  UpdateFunctionCodeCommand,
  PublishVersionCommand,
  UpdateAliasCommand,
  CreateAliasCommand,
  GetAliasCommand,
  waitUntilFunctionUpdated
} from '@aws-sdk/client-lambda';
import { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Deploy handler Lambda created with full deployment flow: artifact download, S3 upload, Lambda update, version publishing, and atomic alias update for zero-downtime deployment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deploy-handler to infrastructure with alias-based routing</name>
  <files>infra/deployment.ts, infra/build-pipeline.ts, buildspecs/nextjs-build.yml</files>
  <action>
**Part A: Add deploy-handler Lambda to infra/deployment.ts**

```typescript
// Deploy handler Lambda - triggered after CodeBuild completes
export const deployHandler = new sst.aws.Function("DeployHandler", {
  handler: "packages/functions/deploy-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "5 minutes", // Deployment can take time
  memory: "512 MB",
  environment: {
    SERVER_FUNCTION_NAME: serverFunction.name,
    IMAGE_FUNCTION_NAME: imageFunction.name,
    STATIC_ASSETS_BUCKET: staticAssetsBucket.name,
  },
  link: [deploymentsTable, artifactsBucket, staticAssetsBucket],
  permissions: [
    // Lambda permissions for updating function code, publishing versions, and managing aliases
    {
      actions: [
        "lambda:UpdateFunctionCode",
        "lambda:PublishVersion",
        "lambda:GetFunction",
        "lambda:GetFunctionConfiguration",
        "lambda:CreateAlias",
        "lambda:UpdateAlias",
        "lambda:GetAlias",
      ],
      resources: [
        serverFunction.arn,
        imageFunction.arn,
        // Include versioned ARNs pattern
        `${serverFunction.arn}:*`,
        `${imageFunction.arn}:*`,
      ],
    },
  ],
});
```

**Part B: Configure server Lambda to be invoked via alias**

Update serverFunction and imageFunction to expose alias-based invocation:

```typescript
// Create initial 'live' alias pointing to $LATEST (will be updated by deploy-handler)
// This is needed so CloudFront/Function URL can target the alias from the start
const serverFunctionAlias = new aws.lambda.Alias("ServerFunctionLiveAlias", {
  name: "live",
  functionName: serverFunction.name,
  functionVersion: "$LATEST", // Initial; deploy-handler will update to specific versions
  description: "Live traffic alias - updated by deploy-handler",
});

const imageFunctionAlias = new aws.lambda.Alias("ImageFunctionLiveAlias", {
  name: "live",
  functionName: imageFunction.name,
  functionVersion: "$LATEST",
  description: "Live traffic alias - updated by deploy-handler",
});

// Update CloudFront origin to use alias ARN instead of function ARN
// In the distribution config, use serverFunctionAlias.arn instead of serverFunction.arn
```

**Part C: Update CodeBuild post_build phase (infra/build-pipeline.ts)**

Modify the embedded buildspec to invoke deploy-handler after successful build:

In the `post_build` phase, add:
```yaml
# After uploading artifacts to S3, trigger deployment
- |
  aws lambda invoke \
    --function-name $DEPLOY_HANDLER_NAME \
    --invocation-type Event \
    --cli-binary-format raw-in-base64-out \
    --payload "{\"deploymentId\":\"$DEPLOYMENT_ID\",\"projectId\":\"$PROJECT_ID\",\"artifactPath\":\"$ARTIFACT_PATH\"}" \
    /dev/null
```

Add environment variable to CodeBuild:
```typescript
environmentVariables: [
  // ... existing vars
  {
    name: "DEPLOY_HANDLER_NAME",
    value: deployHandler.name, // Reference from deployment.ts
  },
],
```

**Part D: Grant CodeBuild permission to invoke deploy-handler**

Add IAM policy to CodeBuild role:
```typescript
{
  actions: ["lambda:InvokeFunction"],
  resources: [deployHandler.arn],
}
```

**Import order in sst.config.ts:**
Since build-pipeline.ts needs deployHandler from deployment.ts, ensure deployment.ts is imported before build-pipeline.ts.
  </action>
  <verify>
Deploy and test:
```bash
npx sst dev
# Verify deploy handler Lambda exists with alias permissions
# Verify server function has 'live' alias created
# Verify CodeBuild project has DEPLOY_HANDLER_NAME env var
aws lambda get-alias --function-name $SERVER_FUNCTION_NAME --name live
```
  </verify>
  <done>
Deploy handler Lambda integrated with alias-based routing. CloudFront invokes alias, deploy-handler atomically updates alias to new version for zero-downtime deployment (DEPLOY-04).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx sst dev` deploys without errors
2. Deploy handler Lambda exists with correct permissions (including alias management)
3. Server function has 'live' alias: `aws lambda get-alias --function-name X --name live`
4. CodeBuild project includes DEPLOY_HANDLER_NAME environment variable
5. Manual test: Trigger a build and verify deployment flow:
   - Build completes
   - Deploy handler is invoked
   - Lambda code is updated
   - Lambda version is published
   - **Lambda alias 'live' updated to new version** (zero-downtime)
   - Deployment record updated with version ARN
6. Zero-downtime test: During deployment, existing requests continue to work (no 5xx errors)
</verification>

<success_criteria>
- Deploy handler Lambda processes build artifacts correctly
- Lambda function code updates and version publishing works
- Static assets uploaded to S3 with correct cache headers
- Deployment record updated with Lambda version ARNs
- CodeBuild triggers deployment after successful build
- **Lambda alias provides atomic traffic shift (DEPLOY-04 zero-downtime)**
- No request failures during deployment transition
</success_criteria>

<output>
After completion, create `.planning/phases/02-deployment-cdn/02-02-SUMMARY.md`
</output>
