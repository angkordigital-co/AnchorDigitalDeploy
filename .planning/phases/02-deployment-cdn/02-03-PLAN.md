---
phase: 02-deployment-cdn
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/functions/rollback-handler/index.ts
  - packages/functions/domains-handler/index.ts
  - packages/core/db/domains.ts
  - infra/database.ts
  - infra/webhooks.ts
  - infra/deployment.ts
autonomous: true

must_haves:
  truths:
    - "User can rollback to any previous deployment instantly"
    - "User can configure custom domain for a project"
    - "SSL certificate is provisioned automatically for custom domains"
    - "User receives DNS configuration instructions"
    - "Rollback updates Lambda alias to use previous version"
    - "CloudFront distribution updated with custom domain after certificate validation"
  artifacts:
    - path: "packages/functions/rollback-handler/index.ts"
      provides: "Rollback API handler"
      exports: ["handler"]
    - path: "packages/functions/domains-handler/index.ts"
      provides: "Custom domain CRUD and ACM provisioning"
      exports: ["handler"]
    - path: "packages/core/db/domains.ts"
      provides: "Domain database operations"
      exports: ["createDomain", "getDomain", "listProjectDomains", "updateDomainCertificate"]
  key_links:
    - from: "packages/functions/rollback-handler/index.ts"
      to: "Lambda API"
      via: "updateAlias to target version"
      pattern: "UpdateAliasCommand"
    - from: "packages/functions/domains-handler/index.ts"
      to: "ACM API"
      via: "@aws-sdk/client-acm requestCertificate"
      pattern: "RequestCertificateCommand"
    - from: "packages/functions/domains-handler/index.ts"
      to: "CloudFront API"
      via: "@aws-sdk/client-cloudfront updateDistribution"
      pattern: "UpdateDistributionCommand"
    - from: "infra/webhooks.ts"
      to: "packages/functions/rollback-handler"
      via: "API route definition"
      pattern: "POST.*rollback"
---

<objective>
Create rollback API for instant deployment reversion and custom domain management with automatic SSL certificate provisioning and CloudFront configuration.

Purpose: Enable users to instantly rollback to previous deployments using Lambda alias switching (atomic, zero-downtime), and configure custom domains with automatic ACM certificate provisioning, DNS instructions, and CloudFront distribution updates.

Output: Working rollback API endpoint and custom domain API with full ACM + CloudFront integration.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deployment-cdn/02-RESEARCH.md
@.planning/phases/02-deployment-cdn/02-01-SUMMARY.md
@.planning/phases/02-deployment-cdn/02-02-SUMMARY.md

# Existing infrastructure
@infra/deployment.ts
@infra/webhooks.ts
@packages/core/schemas/deployment.ts
@packages/core/schemas/domain.ts
@packages/core/db/deployments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rollback-handler Lambda with alias-based instant rollback</name>
  <files>packages/functions/rollback-handler/index.ts</files>
  <action>
Create the rollback handler that reverts to a previous deployment version by updating Lambda aliases (instant, zero-downtime):

**API Endpoint:** POST /projects/{projectId}/rollback

**Request Body:**
```typescript
interface RollbackRequest {
  targetDeploymentId: string; // Deployment to rollback to
}
```

**Rollback Flow (using aliases for instant rollback):**

1. **Validate request**:
   - Verify projectId exists
   - Verify targetDeploymentId exists and belongs to projectId
   - Verify target deployment has `lambdaServerVersionArn` (was successfully deployed)

2. **Get target deployment** from DynamoDB:
   ```typescript
   const targetDeployment = await getDeployment(targetDeploymentId);
   if (!targetDeployment.lambdaServerVersionArn) {
     throw new Error('Target deployment has no version ARN - cannot rollback');
   }
   // Extract version number from ARN: arn:aws:lambda:region:account:function:name:VERSION
   const serverVersion = targetDeployment.lambdaServerVersionArn.split(':').pop();
   const imageVersion = targetDeployment.lambdaImageVersionArn?.split(':').pop();
   ```

3. **Get current alias state** (for rollback record):
   ```typescript
   import { GetAliasCommand, UpdateAliasCommand } from '@aws-sdk/client-lambda';

   const LIVE_ALIAS = 'live';

   const currentAlias = await lambda.send(new GetAliasCommand({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     Name: LIVE_ALIAS,
   }));
   const previousVersion = currentAlias.FunctionVersion;
   ```

4. **Update Lambda alias to target version** (INSTANT ROLLBACK):
   ```typescript
   await lambda.send(new UpdateAliasCommand({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     Name: LIVE_ALIAS,
     FunctionVersion: serverVersion,
     Description: `Rollback to deployment ${targetDeploymentId} at ${new Date().toISOString()}`,
   }));

   // Also update image function alias if applicable
   if (imageVersion) {
     await lambda.send(new UpdateAliasCommand({
       FunctionName: process.env.IMAGE_FUNCTION_NAME,
       Name: LIVE_ALIAS,
       FunctionVersion: imageVersion,
     }));
   }
   ```

   **Why alias update is instant:**
   - No code re-upload needed - version already exists
   - Alias update is atomic (<1 second)
   - Traffic shifts immediately
   - Previous version still exists for re-rollback

5. **Create rollback deployment record**:
   ```typescript
   const rollbackDeployment = await createDeployment({
     projectId,
     commitSha: targetDeployment.commitSha,
     branch: targetDeployment.branch,
     status: 'deployed',
     lambdaServerVersionArn: targetDeployment.lambdaServerVersionArn,
     lambdaImageVersionArn: targetDeployment.lambdaImageVersionArn,
     deployedAt: Date.now(),
     version: `rollback-${targetDeploymentId}-${Date.now()}`,
     rollbackFrom: previousVersion, // Track what we rolled back from
     rollbackTo: targetDeploymentId,
     isRollback: true,
   });
   ```

6. **Return rollback result**:
   ```typescript
   return {
     statusCode: 200,
     body: JSON.stringify({
       message: 'Rollback successful',
       deploymentId: rollbackDeployment.deploymentId,
       rolledBackTo: targetDeploymentId,
       previousVersion: previousVersion,
       newAliasVersion: serverVersion,
       rollbackTimeMs: Date.now() - startTime, // Should be <1000ms
     }),
   };
   ```

**Environment variables:**
- SERVER_FUNCTION_NAME
- IMAGE_FUNCTION_NAME
- DEPLOYMENTS_TABLE

**Error handling:**
- 400: Missing targetDeploymentId
- 404: Project or deployment not found
- 409: Target deployment not deployable (no version ARN)
- 500: Lambda alias update failed

**AWS SDK imports:**
```typescript
import { LambdaClient, GetAliasCommand, UpdateAliasCommand } from '@aws-sdk/client-lambda';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Rollback handler created with instant alias-based rollback. No code re-upload needed - just atomic alias switch.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domains-handler Lambda with ACM + CloudFront integration</name>
  <files>packages/functions/domains-handler/index.ts, packages/core/db/domains.ts, infra/database.ts</files>
  <action>
**Part A: Create DomainsTable in infra/database.ts**

```typescript
export const domainsTable = new sst.aws.Dynamo("DomainsTable", {
  fields: {
    domainId: "string",
    projectId: "string",
  },
  primaryIndex: { hashKey: "domainId" },
  globalIndexes: {
    byProject: { hashKey: "projectId" },
  },
});
```

**Part B: Create domains database functions (packages/core/db/domains.ts)**

```typescript
import { DynamoDBDocumentClient, PutCommand, GetCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { DomainSchema } from '../schemas/domain.js';

export async function createDomain(domain: z.infer<typeof DomainSchema>) {...}
export async function getDomain(domainId: string) {...}
export async function listProjectDomains(projectId: string) {...}
export async function updateDomainCertificate(domainId: string, certData: {...}) {...}
export async function updateDomainCloudFrontStatus(domainId: string, status: 'pending' | 'active' | 'failed') {...}
export async function deleteDomain(domainId: string) {...}
```

**Part C: Create domains-handler Lambda with CloudFront update**

**API Endpoints:**
- GET /projects/{projectId}/domains - List domains for project
- POST /projects/{projectId}/domains - Add custom domain
- GET /projects/{projectId}/domains/{domainId} - Get domain details + DNS instructions
- DELETE /projects/{projectId}/domains/{domainId} - Remove domain

**POST /projects/{projectId}/domains - Add Domain Flow:**

1. **Validate domain format**:
   ```typescript
   const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}$/;
   if (!domainRegex.test(domain)) {
     return { statusCode: 400, body: 'Invalid domain format' };
   }
   ```

2. **Request ACM certificate in us-east-1** (CloudFront requirement):
   ```typescript
   import { ACMClient, RequestCertificateCommand, DescribeCertificateCommand } from '@aws-sdk/client-acm';

   // IMPORTANT: ACM client must use us-east-1 for CloudFront
   const acm = new ACMClient({ region: 'us-east-1' });

   const certResult = await acm.send(new RequestCertificateCommand({
     DomainName: domain,
     ValidationMethod: 'DNS',
     Tags: [
       { Key: 'Project', Value: projectId },
       { Key: 'ManagedBy', Value: 'anchor-deploy' },
     ],
   }));
   ```

3. **Get DNS validation records**:
   ```typescript
   // Wait a moment for ACM to generate validation records
   await new Promise(resolve => setTimeout(resolve, 5000));

   const certDetails = await acm.send(new DescribeCertificateCommand({
     CertificateArn: certResult.CertificateArn,
   }));

   const dnsValidation = certDetails.Certificate?.DomainValidationOptions?.[0];
   ```

4. **Store domain record** in DynamoDB:
   ```typescript
   const domainRecord = {
     domainId: `DOM-${Date.now()}`,
     projectId,
     domain,
     certificateArn: certResult.CertificateArn,
     certificateStatus: 'pending_validation',
     cloudFrontStatus: 'pending', // Will be updated after cert validation
     dnsValidation: {
       name: dnsValidation?.ResourceRecord?.Name,
       value: dnsValidation?.ResourceRecord?.Value,
       type: 'CNAME',
     },
     createdAt: Date.now(),
     updatedAt: Date.now(),
   };
   await createDomain(domainRecord);
   ```

5. **Return DNS instructions** (DOMAIN-04 requirement):
   ```typescript
   return {
     statusCode: 201,
     body: JSON.stringify({
       domainId: domainRecord.domainId,
       domain,
       status: 'pending_validation',
       dnsInstructions: {
         message: 'Add the following DNS record to validate your domain:',
         recordType: 'CNAME',
         recordName: dnsValidation?.ResourceRecord?.Name,
         recordValue: dnsValidation?.ResourceRecord?.Value,
         note: 'After adding the DNS record, certificate validation typically completes within 30 minutes.',
       },
       cloudfrontCname: {
         message: 'After certificate is issued, add this CNAME to point your domain to CloudFront:',
         recordType: 'CNAME',
         recordName: domain,
         recordValue: process.env.CLOUDFRONT_DOMAIN, // e.g., d1234abcd.cloudfront.net
       },
     }),
   };
   ```

**GET /projects/{projectId}/domains/{domainId} - Get Status + Update CloudFront:**

This endpoint checks certificate status and updates CloudFront when certificate is issued:

```typescript
import { CloudFrontClient, GetDistributionConfigCommand, UpdateDistributionCommand } from '@aws-sdk/client-cloudfront';

const cloudfront = new CloudFrontClient({ region: 'us-east-1' });

async function handler(event) {
  const domainRecord = await getDomain(domainId);

  // Check current certificate status from ACM
  const certDetails = await acm.send(new DescribeCertificateCommand({
    CertificateArn: domainRecord.certificateArn,
  }));

  const certStatus = certDetails.Certificate?.Status;

  // If certificate just became ISSUED and CloudFront not yet updated
  if (certStatus === 'ISSUED' && domainRecord.cloudFrontStatus === 'pending') {
    // UPDATE CLOUDFRONT DISTRIBUTION WITH CUSTOM DOMAIN
    await addDomainToCloudFront(domainRecord.domain, domainRecord.certificateArn);
    await updateDomainCloudFrontStatus(domainId, 'active');
    domainRecord.cloudFrontStatus = 'active';
  }

  return {
    statusCode: 200,
    body: JSON.stringify({
      ...domainRecord,
      certificateStatus: certStatus,
      isActive: domainRecord.cloudFrontStatus === 'active',
    }),
  };
}

async function addDomainToCloudFront(domain: string, certificateArn: string) {
  const distributionId = process.env.CLOUDFRONT_DISTRIBUTION_ID;

  // Get current distribution config
  const getConfigResult = await cloudfront.send(new GetDistributionConfigCommand({
    Id: distributionId,
  }));

  const config = getConfigResult.DistributionConfig;
  const etag = getConfigResult.ETag;

  // Add the custom domain to Aliases
  const currentAliases = config.Aliases?.Items || [];
  if (!currentAliases.includes(domain)) {
    config.Aliases = {
      Quantity: currentAliases.length + 1,
      Items: [...currentAliases, domain],
    };
  }

  // Update ViewerCertificate to use ACM certificate
  config.ViewerCertificate = {
    ACMCertificateArn: certificateArn,
    SSLSupportMethod: 'sni-only',
    MinimumProtocolVersion: 'TLSv1.2_2021',
    CloudFrontDefaultCertificate: false,
  };

  // Update the distribution
  await cloudfront.send(new UpdateDistributionCommand({
    Id: distributionId,
    IfMatch: etag,
    DistributionConfig: config,
  }));
}
```

**DELETE /projects/{projectId}/domains/{domainId}:**

Also removes domain from CloudFront and deletes ACM certificate:
```typescript
async function deleteDomainHandler(domainId: string) {
  const domainRecord = await getDomain(domainId);

  // Remove from CloudFront
  await removeDomainFromCloudFront(domainRecord.domain);

  // Delete ACM certificate
  await acm.send(new DeleteCertificateCommand({
    CertificateArn: domainRecord.certificateArn,
  }));

  // Delete from database
  await deleteDomain(domainId);
}
```

**Environment variables:**
- DOMAINS_TABLE
- CLOUDFRONT_DOMAIN
- CLOUDFRONT_DISTRIBUTION_ID

**AWS SDK imports:**
```typescript
import { ACMClient, RequestCertificateCommand, DescribeCertificateCommand, DeleteCertificateCommand } from '@aws-sdk/client-acm';
import { CloudFrontClient, GetDistributionConfigCommand, UpdateDistributionCommand } from '@aws-sdk/client-cloudfront';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Domains handler created with ACM certificate provisioning, DNS instructions, and CloudFront distribution update when certificate is validated. DomainsTable created in DynamoDB.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add rollback and domains API routes with proper permissions</name>
  <files>infra/webhooks.ts, infra/deployment.ts, sst.config.ts</files>
  <action>
**Part A: Add rollback-handler and domains-handler Lambdas to infra/deployment.ts**

```typescript
// Rollback handler - instant alias-based rollback
export const rollbackHandler = new sst.aws.Function("RollbackHandler", {
  handler: "packages/functions/rollback-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "30 seconds", // Alias update is fast
  memory: "256 MB",
  environment: {
    SERVER_FUNCTION_NAME: serverFunction.name,
    IMAGE_FUNCTION_NAME: imageFunction.name,
  },
  link: [deploymentsTable],
  permissions: [
    {
      actions: [
        "lambda:GetAlias",
        "lambda:UpdateAlias",
      ],
      resources: [
        serverFunction.arn,
        imageFunction.arn,
        `${serverFunction.arn}:*`,
        `${imageFunction.arn}:*`,
      ],
    },
  ],
});

// Domains handler - ACM + CloudFront integration
export const domainsHandler = new sst.aws.Function("DomainsHandler", {
  handler: "packages/functions/domains-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "30 seconds",
  memory: "256 MB",
  environment: {
    CLOUDFRONT_DOMAIN: distribution.domainName,
    CLOUDFRONT_DISTRIBUTION_ID: distribution.id,
  },
  link: [domainsTable],
  permissions: [
    {
      // ACM permissions - note region is us-east-1
      actions: [
        "acm:RequestCertificate",
        "acm:DescribeCertificate",
        "acm:DeleteCertificate",
        "acm:ListCertificates",
      ],
      resources: ["*"], // ACM doesn't support resource-level permissions
    },
    {
      // CloudFront permissions for distribution update
      actions: [
        "cloudfront:GetDistribution",
        "cloudfront:GetDistributionConfig",
        "cloudfront:UpdateDistribution",
      ],
      resources: [
        `arn:aws:cloudfront::${$app.aws.account}:distribution/${distribution.id}`,
      ],
    },
  ],
});
```

**Part B: Add API routes to infra/webhooks.ts**

Import handlers from deployment.ts and add routes:

```typescript
import { rollbackHandler, domainsHandler } from "./deployment.js";

// Add to webhookApi routes:
{
  method: "POST",
  path: "/projects/{projectId}/rollback",
  handler: rollbackHandler.arn,
},
{
  method: "GET",
  path: "/projects/{projectId}/domains",
  handler: domainsHandler.arn,
},
{
  method: "POST",
  path: "/projects/{projectId}/domains",
  handler: domainsHandler.arn,
},
{
  method: "GET",
  path: "/projects/{projectId}/domains/{domainId}",
  handler: domainsHandler.arn,
},
{
  method: "DELETE",
  path: "/projects/{projectId}/domains/{domainId}",
  handler: domainsHandler.arn,
},
```

**Part C: Update sst.config.ts**

Export domainsTable from config:
```typescript
const { domainsTable } = await import("./infra/database.js");
// ...
return {
  // ... existing
  domainsTable: domainsTable.name,
};
```
  </action>
  <verify>
Deploy and test full rollback functionality:
```bash
npx sst dev

# === ROLLBACK VERIFICATION ===
# Step 1: Create first deployment (deployment A)
# Trigger a build and wait for it to complete
# Record: DEPLOYMENT_A_ID, SERVER_VERSION_A

# Get current alias version before any changes
aws lambda get-alias --function-name $SERVER_FUNCTION_NAME --name live
# Record the FunctionVersion (should be version A)

# Step 2: Create second deployment (deployment B)
# Make a code change and trigger another build
# Record: DEPLOYMENT_B_ID, SERVER_VERSION_B

# Verify alias now points to version B
aws lambda get-alias --function-name $SERVER_FUNCTION_NAME --name live
# FunctionVersion should now be SERVER_VERSION_B

# Step 3: Execute rollback to deployment A
curl -X POST https://API_URL/projects/{projectId}/rollback \
  -H "Content-Type: application/json" \
  -H "x-user-id: test-user" \
  -d '{"targetDeploymentId": "DEPLOYMENT_A_ID"}'
# Should return 200 with rollbackTimeMs < 1000

# Step 4: Verify alias now points back to version A
aws lambda get-alias --function-name $SERVER_FUNCTION_NAME --name live
# FunctionVersion should now be SERVER_VERSION_A (from deployment A)

# === DOMAINS VERIFICATION ===
# Test domains endpoint exists
curl https://API_URL/projects/test/domains \
  -H "x-user-id: test-user"
# Should return empty array, not route not found
```
  </verify>
  <done>
Rollback and domains API endpoints deployed. Rollback uses alias switching for instant (<1s) reversion. Domains handler has CloudFront update permissions for automatic distribution configuration after certificate validation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx sst dev` deploys without errors
2. Rollback endpoint: POST /projects/{projectId}/rollback returns proper error for non-existent deployment
3. **Rollback actually works:**
   - Deploy version A, record alias version
   - Deploy version B, verify alias changed
   - Rollback to A, verify alias changed back to A's version
4. Domains endpoints: GET/POST /projects/{projectId}/domains work
5. DomainsTable exists in DynamoDB
6. ACM certificate can be requested (test with real domain if available)
7. DNS instructions returned in domain creation response
8. **CloudFront updated when certificate validates** (GET /domains/{domainId} triggers update)
</verification>

<success_criteria>
- Rollback API accepts targetDeploymentId and updates Lambda alias to that version
- Rollback is instant (<1 second) - no code re-upload
- Rollback creates new deployment record with rollback metadata
- Domain API accepts custom domain and requests ACM certificate
- ACM certificate requested in us-east-1 (CloudFront requirement)
- DNS validation instructions returned to user
- CloudFront CNAME instructions returned to user
- **CloudFront distribution updated with custom domain + ACM certificate after validation**
- DomainsTable stores domain configuration
- All API endpoints accessible via API Gateway
</success_criteria>

<output>
After completion, create `.planning/phases/02-deployment-cdn/02-03-SUMMARY.md`
</output>
