---
phase: 02-deployment-cdn
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/functions/rollback-handler/index.ts
  - packages/functions/domains-handler/index.ts
  - packages/core/db/domains.ts
  - infra/database.ts
  - infra/webhooks.ts
  - infra/deployment.ts
autonomous: true

must_haves:
  truths:
    - "User can rollback to any previous deployment instantly"
    - "User can configure custom domain for a project"
    - "SSL certificate is provisioned automatically for custom domains"
    - "User receives DNS configuration instructions"
    - "Rollback updates Lambda to use previous version ARN"
  artifacts:
    - path: "packages/functions/rollback-handler/index.ts"
      provides: "Rollback API handler"
      exports: ["handler"]
    - path: "packages/functions/domains-handler/index.ts"
      provides: "Custom domain CRUD and ACM provisioning"
      exports: ["handler"]
    - path: "packages/core/db/domains.ts"
      provides: "Domain database operations"
      exports: ["createDomain", "getDomain", "listProjectDomains", "updateDomainCertificate"]
  key_links:
    - from: "packages/functions/rollback-handler/index.ts"
      to: "Lambda API"
      via: "updateFunctionConfiguration with version"
      pattern: "UpdateFunctionConfigurationCommand"
    - from: "packages/functions/domains-handler/index.ts"
      to: "ACM API"
      via: "@aws-sdk/client-acm requestCertificate"
      pattern: "RequestCertificateCommand"
    - from: "infra/webhooks.ts"
      to: "packages/functions/rollback-handler"
      via: "API route definition"
      pattern: "POST.*rollback"
---

<objective>
Create rollback API for instant deployment reversion and custom domain management with automatic SSL certificate provisioning.

Purpose: Enable users to instantly rollback to previous deployments using stored Lambda version ARNs, and configure custom domains with automatic ACM certificate provisioning and DNS instructions.

Output: Working rollback API endpoint and custom domain API with ACM integration.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-deployment-cdn/02-RESEARCH.md
@.planning/phases/02-deployment-cdn/02-01-SUMMARY.md
@.planning/phases/02-deployment-cdn/02-02-SUMMARY.md

# Existing infrastructure
@infra/deployment.ts
@infra/webhooks.ts
@packages/core/schemas/deployment.ts
@packages/core/schemas/domain.ts
@packages/core/db/deployments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rollback-handler Lambda</name>
  <files>packages/functions/rollback-handler/index.ts</files>
  <action>
Create the rollback handler that reverts to a previous deployment version:

**API Endpoint:** POST /projects/{projectId}/rollback

**Request Body:**
```typescript
interface RollbackRequest {
  targetDeploymentId: string; // Deployment to rollback to
}
```

**Rollback Flow:**

1. **Validate request**:
   - Verify projectId exists
   - Verify targetDeploymentId exists and belongs to projectId
   - Verify target deployment has `lambdaServerVersionArn` (was successfully deployed)

2. **Get target deployment** from DynamoDB:
   ```typescript
   const targetDeployment = await getDeployment(targetDeploymentId);
   if (!targetDeployment.lambdaServerVersionArn) {
     throw new Error('Target deployment has no version ARN - cannot rollback');
   }
   ```

3. **Update server Lambda to use target version**:
   For Lambda function URLs, we need to update the alias or use function URL routing.

   **Option A (Simpler - use in v1):** Update function configuration to point to version:
   This doesn't work directly with function URLs. Instead, we'll:

   **Option B (v1 approach):** Re-deploy the target version's code:
   ```typescript
   // Get the deployment info for the target version
   const targetVersion = targetDeployment.lambdaServerVersionArn;

   // For v1, update the $LATEST to match the target version's code
   // by re-uploading the artifacts from S3
   await lambda.updateFunctionCode({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     S3Bucket: artifactsBucket,
     S3Key: targetDeployment.artifactPath + '/server-function.zip',
   });

   // Wait for update
   await waitUntilFunctionUpdated({...});

   // Publish new version for this rollback
   const rollbackVersion = await lambda.publishVersion({
     FunctionName: process.env.SERVER_FUNCTION_NAME,
     Description: `Rollback to ${targetDeploymentId}`,
   });
   ```

4. **Create rollback deployment record**:
   ```typescript
   const rollbackDeployment = await createDeployment({
     projectId,
     commitSha: targetDeployment.commitSha,
     branch: targetDeployment.branch,
     status: 'deployed',
     lambdaServerVersionArn: rollbackVersion.FunctionArn,
     deployedAt: Date.now(),
     version: `rollback-${targetDeploymentId}`,
     rollbackFrom: currentActiveDeploymentId,
     rollbackTo: targetDeploymentId,
   });
   ```

5. **Return rollback result**:
   ```typescript
   return {
     statusCode: 200,
     body: JSON.stringify({
       message: 'Rollback successful',
       deploymentId: rollbackDeployment.deploymentId,
       rolledBackTo: targetDeploymentId,
       previousVersion: currentActiveDeploymentId,
     }),
   };
   ```

**Environment variables:**
- SERVER_FUNCTION_NAME
- IMAGE_FUNCTION_NAME
- DEPLOYMENTS_TABLE
- ARTIFACTS_BUCKET

**Error handling:**
- 400: Missing targetDeploymentId
- 404: Project or deployment not found
- 409: Target deployment not deployable (no version ARN)
- 500: Lambda update failed
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Rollback handler created. Reverts to previous deployment by re-deploying target version's artifacts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create domains-handler Lambda with ACM integration</name>
  <files>packages/functions/domains-handler/index.ts, packages/core/db/domains.ts, infra/database.ts</files>
  <action>
**Part A: Create DomainsTable in infra/database.ts**

```typescript
export const domainsTable = new sst.aws.Dynamo("DomainsTable", {
  fields: {
    domainId: "string",
    projectId: "string",
  },
  primaryIndex: { hashKey: "domainId" },
  globalIndexes: {
    byProject: { hashKey: "projectId" },
  },
});
```

**Part B: Create domains database functions (packages/core/db/domains.ts)**

```typescript
import { DynamoDBDocumentClient, PutCommand, GetCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { DomainSchema } from '../schemas/domain.js';

export async function createDomain(domain: z.infer<typeof DomainSchema>) {...}
export async function getDomain(domainId: string) {...}
export async function listProjectDomains(projectId: string) {...}
export async function updateDomainCertificate(domainId: string, certData: {...}) {...}
export async function deleteDomain(domainId: string) {...}
```

**Part C: Create domains-handler Lambda**

**API Endpoints:**
- GET /projects/{projectId}/domains - List domains for project
- POST /projects/{projectId}/domains - Add custom domain
- GET /projects/{projectId}/domains/{domainId} - Get domain details + DNS instructions
- DELETE /projects/{projectId}/domains/{domainId} - Remove domain

**POST /projects/{projectId}/domains - Add Domain Flow:**

1. **Validate domain format**:
   ```typescript
   const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}$/;
   if (!domainRegex.test(domain)) {
     return { statusCode: 400, body: 'Invalid domain format' };
   }
   ```

2. **Request ACM certificate in us-east-1** (CloudFront requirement):
   ```typescript
   import { ACMClient, RequestCertificateCommand, DescribeCertificateCommand } from '@aws-sdk/client-acm';

   // IMPORTANT: ACM client must use us-east-1 for CloudFront
   const acm = new ACMClient({ region: 'us-east-1' });

   const certResult = await acm.send(new RequestCertificateCommand({
     DomainName: domain,
     ValidationMethod: 'DNS',
     Tags: [
       { Key: 'Project', Value: projectId },
       { Key: 'ManagedBy', Value: 'anchor-deploy' },
     ],
   }));
   ```

3. **Get DNS validation records**:
   ```typescript
   // Wait a moment for ACM to generate validation records
   await new Promise(resolve => setTimeout(resolve, 5000));

   const certDetails = await acm.send(new DescribeCertificateCommand({
     CertificateArn: certResult.CertificateArn,
   }));

   const dnsValidation = certDetails.Certificate?.DomainValidationOptions?.[0];
   ```

4. **Store domain record** in DynamoDB:
   ```typescript
   const domainRecord = {
     domainId: `DOM-${Date.now()}`,
     projectId,
     domain,
     certificateArn: certResult.CertificateArn,
     certificateStatus: 'pending',
     dnsValidation: {
       name: dnsValidation?.ResourceRecord?.Name,
       value: dnsValidation?.ResourceRecord?.Value,
       type: 'CNAME',
     },
     createdAt: Date.now(),
     updatedAt: Date.now(),
   };
   await createDomain(domainRecord);
   ```

5. **Return DNS instructions** (DOMAIN-04 requirement):
   ```typescript
   return {
     statusCode: 201,
     body: JSON.stringify({
       domainId: domainRecord.domainId,
       domain,
       status: 'pending_validation',
       dnsInstructions: {
         message: 'Add the following DNS record to validate your domain:',
         recordType: 'CNAME',
         recordName: dnsValidation?.ResourceRecord?.Name,
         recordValue: dnsValidation?.ResourceRecord?.Value,
         note: 'After adding the DNS record, certificate validation typically completes within 30 minutes.',
       },
       cloudfrontCname: {
         message: 'After certificate is issued, add this CNAME to point your domain to CloudFront:',
         recordType: 'CNAME',
         recordName: domain,
         recordValue: process.env.CLOUDFRONT_DOMAIN, // e.g., d1234abcd.cloudfront.net
       },
     }),
   };
   ```

**GET /projects/{projectId}/domains/{domainId} - Get Status:**
- Return current certificate status
- If status changed from pending to issued, update CloudFront with domain

**Environment variables:**
- DOMAINS_TABLE
- CLOUDFRONT_DOMAIN
- CLOUDFRONT_DISTRIBUTION_ID

**AWS SDK imports:**
```typescript
import { ACMClient, RequestCertificateCommand, DescribeCertificateCommand, DeleteCertificateCommand } from '@aws-sdk/client-acm';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Domains handler created with ACM certificate provisioning and DNS instructions. DomainsTable created in DynamoDB.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add rollback and domains API routes</name>
  <files>infra/webhooks.ts, infra/deployment.ts, sst.config.ts</files>
  <action>
**Part A: Add rollback-handler and domains-handler Lambdas to infra/deployment.ts**

```typescript
// Rollback handler
export const rollbackHandler = new sst.aws.Function("RollbackHandler", {
  handler: "packages/functions/rollback-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "2 minutes",
  memory: "512 MB",
  environment: {
    SERVER_FUNCTION_NAME: serverFunction.name,
    IMAGE_FUNCTION_NAME: imageFunction.name,
  },
  link: [deploymentsTable, artifactsBucket],
  permissions: [
    {
      actions: [
        "lambda:UpdateFunctionCode",
        "lambda:PublishVersion",
        "lambda:GetFunction",
        "lambda:GetFunctionConfiguration",
      ],
      resources: [
        serverFunction.arn,
        imageFunction.arn,
        `${serverFunction.arn}:*`,
        `${imageFunction.arn}:*`,
      ],
    },
  ],
});

// Domains handler
export const domainsHandler = new sst.aws.Function("DomainsHandler", {
  handler: "packages/functions/domains-handler/index.handler",
  runtime: "nodejs20.x",
  timeout: "30 seconds",
  memory: "256 MB",
  environment: {
    CLOUDFRONT_DOMAIN: distribution.domainName,
    CLOUDFRONT_DISTRIBUTION_ID: distribution.id,
  },
  link: [domainsTable],
  permissions: [
    {
      // ACM permissions - note region is us-east-1
      actions: [
        "acm:RequestCertificate",
        "acm:DescribeCertificate",
        "acm:DeleteCertificate",
        "acm:ListCertificates",
      ],
      resources: ["*"], // ACM doesn't support resource-level permissions
    },
  ],
});
```

**Part B: Add API routes to infra/webhooks.ts**

Import handlers from deployment.ts and add routes:

```typescript
import { rollbackHandler, domainsHandler } from "./deployment.js";

// Add to webhookApi routes:
{
  method: "POST",
  path: "/projects/{projectId}/rollback",
  handler: rollbackHandler.arn,
},
{
  method: "GET",
  path: "/projects/{projectId}/domains",
  handler: domainsHandler.arn,
},
{
  method: "POST",
  path: "/projects/{projectId}/domains",
  handler: domainsHandler.arn,
},
{
  method: "GET",
  path: "/projects/{projectId}/domains/{domainId}",
  handler: domainsHandler.arn,
},
{
  method: "DELETE",
  path: "/projects/{projectId}/domains/{domainId}",
  handler: domainsHandler.arn,
},
```

**Part C: Update sst.config.ts**

Export domainsTable from config:
```typescript
const { domainsTable } = await import("./infra/database.js");
// ...
return {
  // ... existing
  domainsTable: domainsTable.name,
};
```
  </action>
  <verify>
Deploy and test endpoints:
```bash
npx sst dev

# Test rollback endpoint exists
curl -X POST https://API_URL/projects/test/rollback \
  -H "Content-Type: application/json" \
  -H "x-user-id: test-user" \
  -d '{"targetDeploymentId": "test"}'
# Should return 404 (deployment not found), not 403 or route not found

# Test domains endpoint exists
curl https://API_URL/projects/test/domains \
  -H "x-user-id: test-user"
# Should return empty array or 404, not route not found
```
  </verify>
  <done>
Rollback and domains API endpoints deployed. ACM permissions configured for us-east-1 certificate requests.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx sst dev` deploys without errors
2. Rollback endpoint: POST /projects/{projectId}/rollback returns proper error for non-existent deployment
3. Domains endpoints: GET/POST /projects/{projectId}/domains work
4. DomainsTable exists in DynamoDB
5. ACM certificate can be requested (test with real domain if available)
6. DNS instructions returned in domain creation response
</verification>

<success_criteria>
- Rollback API accepts targetDeploymentId and reverts Lambda to that version
- Rollback creates new deployment record with rollback metadata
- Domain API accepts custom domain and requests ACM certificate
- ACM certificate requested in us-east-1 (CloudFront requirement)
- DNS validation instructions returned to user
- CloudFront CNAME instructions returned to user
- DomainsTable stores domain configuration
- All API endpoints accessible via API Gateway
</success_criteria>

<output>
After completion, create `.planning/phases/02-deployment-cdn/02-03-SUMMARY.md`
</output>
