---
phase: 03-dashboard-observability
plan: 03-03
name: env-vars-custom-domains
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - dashboard/app/(dashboard)/sites/[siteId]/env/page.tsx
  - dashboard/app/(dashboard)/sites/[siteId]/env/actions.ts
  - dashboard/app/(dashboard)/sites/[siteId]/domains/page.tsx
  - dashboard/app/(dashboard)/sites/[siteId]/domains/actions.ts
  - dashboard/components/forms/env-vars-form.tsx
  - dashboard/components/forms/add-domain-form.tsx
  - dashboard/components/tables/domains-table.tsx
autonomous: true
requirements: [DASH-04, DASH-07]

must_haves:
  truths:
    - "User can view current environment variables for a site"
    - "User can add, edit, and delete environment variables"
    - "User can add a custom domain to a site"
    - "User can see DNS validation instructions for pending domains"
    - "User can delete a custom domain"
  artifacts:
    - path: "dashboard/app/(dashboard)/sites/[siteId]/env/page.tsx"
      provides: "Environment variables management page"
    - path: "dashboard/app/(dashboard)/sites/[siteId]/env/actions.ts"
      provides: "Server actions for env var CRUD"
      exports: ["updateEnvVars"]
    - path: "dashboard/app/(dashboard)/sites/[siteId]/domains/page.tsx"
      provides: "Custom domains management page"
    - path: "dashboard/app/(dashboard)/sites/[siteId]/domains/actions.ts"
      provides: "Server actions for domain CRUD"
      exports: ["addDomain", "deleteDomain", "refreshDomainStatus"]
  key_links:
    - from: "dashboard/components/forms/env-vars-form.tsx"
      to: "dashboard/app/(dashboard)/sites/[siteId]/env/actions.ts"
      via: "form action"
      pattern: "action=.*updateEnvVars"
    - from: "dashboard/app/(dashboard)/sites/[siteId]/domains/actions.ts"
      to: "API Gateway domains endpoint"
      via: "fetch call"
      pattern: "fetch.*projects.*domains"
---

<objective>
Build environment variables editor and custom domains configuration pages.

Purpose: Users need to configure their deployments (env vars) and set up custom domains without using CLI or API directly. These are essential management features for any deployment platform.

Output: Env vars page with add/edit/delete, domains page with add domain, DNS instructions, and delete functionality.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-dashboard-observability/03-RESEARCH.md
@.planning/phases/03-dashboard-observability/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Environment Variables Management Page</name>
  <files>
    dashboard/app/(dashboard)/sites/[siteId]/env/page.tsx
    dashboard/app/(dashboard)/sites/[siteId]/env/actions.ts
    dashboard/components/forms/env-vars-form.tsx
    dashboard/components/ui/textarea.tsx
  </files>
  <action>
    1. Install additional shadcn/ui components:
       ```bash
       cd /Users/myownip/workspace/vercel-clone/dashboard
       npx shadcn@latest add textarea alert dialog
       ```

    2. Create dashboard/app/(dashboard)/sites/[siteId]/env/actions.ts:
       ```typescript
       'use server';

       import { auth } from '@/lib/auth';
       import { revalidatePath } from 'next/cache';

       export async function getEnvVars(projectId: string) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/env`,
           {
             headers: { 'x-user-id': session.user.id },
             cache: 'no-store',
           }
         );

         if (!response.ok) throw new Error('Failed to fetch env vars');
         return response.json();
       }

       export async function updateEnvVars(
         projectId: string,
         envVars: Array<{ key: string; value: string; isSecret?: boolean }>
       ) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/env`,
           {
             method: 'PUT',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': session.user.id,
             },
             body: JSON.stringify({ envVars }),
           }
         );

         if (!response.ok) {
           const error = await response.json();
           throw new Error(error.message || 'Failed to update env vars');
         }

         revalidatePath(`/sites/${projectId}/env`);
         return { success: true };
       }
       ```

    3. Create dashboard/components/forms/env-vars-form.tsx:
       - Client component ('use client')
       - Display current env vars as key-value rows
       - Each row: Key input, Value input (masked if isSecret), Delete button
       - Add new row button at bottom
       - Save button calls updateEnvVars server action
       - Use react-hook-form with useFieldArray for dynamic rows
       - Show loading state during save
       - Show success/error toast (use sonner or shadcn toast)

    4. Create dashboard/app/(dashboard)/sites/[siteId]/env/page.tsx:
       ```typescript
       import { auth } from '@/lib/auth';
       import { getEnvVars } from './actions';
       import { EnvVarsForm } from '@/components/forms/env-vars-form';
       import { redirect } from 'next/navigation';

       export default async function EnvVarsPage({
         params,
       }: {
         params: { siteId: string };
       }) {
         const session = await auth();
         if (!session?.user?.id) redirect('/login');

         const envVars = await getEnvVars(params.siteId);

         return (
           <div className="p-6">
             <h1 className="text-2xl font-bold mb-2">Environment Variables</h1>
             <p className="text-muted-foreground mb-6">
               Configure environment variables for your site. Changes require a new deployment.
             </p>
             <EnvVarsForm projectId={params.siteId} initialEnvVars={envVars.envVars || []} />
           </div>
         );
       }
       ```

    5. Install toast library:
       ```bash
       npm install sonner
       ```
       Add Toaster to root layout.
  </action>
  <verify>
    1. Navigate to /sites/[siteId]/env
    2. See current env vars displayed
    3. Add a new env var, click Save
    4. Refresh page - new var persists
    5. Edit existing var, save, verify change persists
    6. Delete a var, save, verify it's removed
  </verify>
  <done>Environment variables page allows viewing, adding, editing, and deleting env vars with persistence via API.</done>
</task>

<task type="auto">
  <name>Task 2: Build Custom Domains Management Page</name>
  <files>
    dashboard/app/(dashboard)/sites/[siteId]/domains/page.tsx
    dashboard/app/(dashboard)/sites/[siteId]/domains/actions.ts
    dashboard/components/forms/add-domain-form.tsx
    dashboard/components/tables/domains-table.tsx
    dashboard/lib/aws/types.ts
  </files>
  <action>
    1. Add Domain type to dashboard/lib/aws/types.ts:
       ```typescript
       export interface Domain {
         domainId: string;
         projectId: string;
         domainName: string;
         certificateArn?: string;
         certificateStatus: 'PENDING_VALIDATION' | 'ISSUED' | 'FAILED';
         cloudFrontStatus?: 'PENDING' | 'DEPLOYED' | 'FAILED';
         validationRecords?: Array<{
           name: string;
           type: string;
           value: string;
         }>;
         createdAt: string;
       }
       ```

    2. Create dashboard/app/(dashboard)/sites/[siteId]/domains/actions.ts:
       ```typescript
       'use server';

       import { auth } from '@/lib/auth';
       import { revalidatePath } from 'next/cache';

       export async function getDomains(projectId: string) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/domains`,
           {
             headers: { 'x-user-id': session.user.id },
             cache: 'no-store',
           }
         );

         if (!response.ok) throw new Error('Failed to fetch domains');
         return response.json();
       }

       export async function addDomain(projectId: string, domainName: string) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/domains`,
           {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'x-user-id': session.user.id,
             },
             body: JSON.stringify({ domainName }),
           }
         );

         if (!response.ok) {
           const error = await response.json();
           throw new Error(error.message || 'Failed to add domain');
         }

         revalidatePath(`/sites/${projectId}/domains`);
         return response.json();
       }

       export async function deleteDomain(projectId: string, domainId: string) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/domains/${domainId}`,
           {
             method: 'DELETE',
             headers: { 'x-user-id': session.user.id },
           }
         );

         if (!response.ok) {
           const error = await response.json();
           throw new Error(error.message || 'Failed to delete domain');
         }

         revalidatePath(`/sites/${projectId}/domains`);
         return { success: true };
       }

       export async function refreshDomainStatus(projectId: string, domainId: string) {
         const session = await auth();
         if (!session?.user?.id) throw new Error('Unauthorized');

         // GET domain endpoint triggers CloudFront update if certificate is issued
         const response = await fetch(
           `${process.env.API_GATEWAY_URL}/projects/${projectId}/domains/${domainId}`,
           {
             headers: { 'x-user-id': session.user.id },
             cache: 'no-store',
           }
         );

         if (!response.ok) throw new Error('Failed to refresh domain status');

         revalidatePath(`/sites/${projectId}/domains`);
         return response.json();
       }
       ```

    3. Create dashboard/components/forms/add-domain-form.tsx:
       - Client component
       - Single input for domain name
       - Validate domain format (basic regex)
       - Submit calls addDomain server action
       - Show loading state
       - On success, show DNS validation instructions from response

    4. Create dashboard/components/tables/domains-table.tsx:
       - Columns: Domain Name, Certificate Status (badge), CloudFront Status, Actions
       - Certificate status badges: PENDING_VALIDATION (yellow), ISSUED (green), FAILED (red)
       - Expand row to show DNS validation records if PENDING_VALIDATION
       - Actions: Refresh Status, Delete
       - Refresh calls refreshDomainStatus
       - Delete shows confirmation dialog, then calls deleteDomain

    5. Create dashboard/app/(dashboard)/sites/[siteId]/domains/page.tsx:
       - Fetch domains with getDomains
       - Render AddDomainForm at top
       - Render DomainsTable below
       - Show empty state if no domains
  </action>
  <verify>
    1. Navigate to /sites/[siteId]/domains
    2. Add a new domain (e.g., test.example.com)
    3. See domain in table with PENDING_VALIDATION status
    4. See DNS validation records displayed
    5. Click Refresh Status - status updates (certificate may still be pending)
    6. Delete a domain - confirm dialog, then removed from table
  </verify>
  <done>Custom domains page allows adding domains with DNS instructions, viewing status, refreshing, and deleting domains.</done>
</task>

</tasks>

<verification>
1. `cd dashboard && npm run build` - builds without errors
2. Environment Variables Page:
   - View current env vars
   - Add new env var, save, refresh - persists
   - Edit env var, save - persists
   - Delete env var, save - removed
3. Custom Domains Page:
   - Add domain - see PENDING_VALIDATION status and DNS records
   - Refresh status - updates from API
   - Delete domain - removed after confirmation
4. Both pages handle errors gracefully (show toast)
</verification>

<success_criteria>
- Env vars page at /sites/[siteId]/env
- Add/edit/delete env vars with save button
- Changes call PUT /projects/{projectId}/env API
- Domains page at /sites/[siteId]/domains
- Add domain form calls POST /projects/{projectId}/domains
- DNS validation records displayed for pending domains
- Refresh status calls GET /projects/{projectId}/domains/{domainId}
- Delete domain calls DELETE endpoint with confirmation
- Error states handled with user feedback
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-observability/03-03-SUMMARY.md`
</output>
