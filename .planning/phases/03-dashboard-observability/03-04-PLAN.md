---
phase: 03-dashboard-observability
plan: 03-04
name: observability-logs-metrics-costs
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - dashboard/app/(dashboard)/sites/[siteId]/logs/page.tsx
  - dashboard/app/(dashboard)/sites/[siteId]/metrics/page.tsx
  - dashboard/app/(dashboard)/sites/[siteId]/costs/page.tsx
  - dashboard/lib/aws/cloudwatch.ts
  - dashboard/lib/aws/cloudwatch-logs.ts
  - dashboard/lib/aws/cost-explorer.ts
  - dashboard/components/logs/log-viewer.tsx
  - dashboard/components/charts/metrics-chart.tsx
  - dashboard/components/charts/cost-breakdown.tsx
autonomous: true
requirements: [OBS-01, OBS-02, OBS-03, OBS-04, OBS-05, DASH-05]

must_haves:
  truths:
    - "User can view runtime logs from Lambda functions"
    - "User can see errors aggregated by type"
    - "User can view response time metrics (p50, p95, p99)"
    - "User can view request count metrics"
    - "User can view AWS cost breakdown for their site"
  artifacts:
    - path: "dashboard/app/(dashboard)/sites/[siteId]/logs/page.tsx"
      provides: "Runtime logs viewer page"
    - path: "dashboard/app/(dashboard)/sites/[siteId]/metrics/page.tsx"
      provides: "Metrics dashboard with charts"
    - path: "dashboard/lib/aws/cloudwatch.ts"
      provides: "CloudWatch metrics fetching"
      exports: ["getLambdaMetrics"]
    - path: "dashboard/lib/aws/cloudwatch-logs.ts"
      provides: "CloudWatch Logs fetching and error aggregation"
      exports: ["getLogs", "getErrorAggregation"]
    - path: "dashboard/lib/aws/cost-explorer.ts"
      provides: "Cost Explorer API calls"
      exports: ["getCostBreakdown"]
    - path: "dashboard/components/charts/metrics-chart.tsx"
      provides: "Recharts line chart for metrics"
  key_links:
    - from: "dashboard/app/(dashboard)/sites/[siteId]/metrics/page.tsx"
      to: "dashboard/lib/aws/cloudwatch.ts"
      via: "getLambdaMetrics call"
      pattern: "getLambdaMetrics"
    - from: "dashboard/lib/aws/cloudwatch.ts"
      to: "AWS CloudWatch"
      via: "GetMetricDataCommand"
      pattern: "GetMetricDataCommand"
    - from: "dashboard/lib/aws/cost-explorer.ts"
      to: "AWS Cost Explorer"
      via: "GetCostAndUsageCommand"
      pattern: "GetCostAndUsageCommand"
---

<objective>
Build observability features: runtime logs, error aggregation, performance metrics, and cost breakdown.

Purpose: Users need visibility into how their deployed applications are performing, what errors are occurring, and how much they're spending on AWS resources.

Output: Logs page with runtime log viewer, metrics page with invocations/errors/duration charts, cost breakdown page with per-service costs.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-dashboard-observability/03-RESEARCH.md
@.planning/phases/03-dashboard-observability/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build CloudWatch Logs Viewer with Error Aggregation</name>
  <files>
    dashboard/lib/aws/cloudwatch-logs.ts
    dashboard/app/(dashboard)/sites/[siteId]/logs/page.tsx
    dashboard/components/logs/log-viewer.tsx
    dashboard/components/logs/error-summary.tsx
  </files>
  <action>
    1. Install AWS SDK CloudWatch Logs client:
       ```bash
       cd /Users/myownip/workspace/vercel-clone/dashboard
       npm install @aws-sdk/client-cloudwatch-logs
       ```

    2. Create dashboard/lib/aws/cloudwatch-logs.ts:
       ```typescript
       import {
         CloudWatchLogsClient,
         FilterLogEventsCommand,
         StartQueryCommand,
         GetQueryResultsCommand,
       } from '@aws-sdk/client-cloudwatch-logs';

       const logs = new CloudWatchLogsClient({ region: process.env.AWS_REGION });

       export async function getLogs(
         logGroupName: string,
         startTime: number,
         endTime: number,
         filterPattern?: string
       ) {
         const command = new FilterLogEventsCommand({
           logGroupName,
           startTime,
           endTime,
           filterPattern,
           limit: 100,
         });

         const response = await logs.send(command);
         return response.events || [];
       }

       export async function getErrorAggregation(logGroupName: string, hours: number = 24) {
         const endTime = Date.now();
         const startTime = endTime - hours * 60 * 60 * 1000;

         const query = `
           fields @timestamp, @message
           | filter @message like /ERROR|Exception|error/
           | parse @message /(?<errorType>[A-Za-z]+Error|Exception)/
           | stats count(*) as count by errorType
           | sort count desc
           | limit 10
         `;

         const startCommand = new StartQueryCommand({
           logGroupName,
           startTime: Math.floor(startTime / 1000),
           endTime: Math.floor(endTime / 1000),
           queryString: query,
         });

         const { queryId } = await logs.send(startCommand);

         // Poll for results (max 10 attempts)
         for (let i = 0; i < 10; i++) {
           await new Promise((r) => setTimeout(r, 1000));
           const getCommand = new GetQueryResultsCommand({ queryId });
           const response = await logs.send(getCommand);

           if (response.status === 'Complete') {
             return response.results?.map((row) => ({
               errorType: row.find((f) => f.field === 'errorType')?.value || 'Unknown',
               count: parseInt(row.find((f) => f.field === 'count')?.value || '0'),
             })) || [];
           }
         }

         return [];
       }
       ```

    3. Create dashboard/components/logs/log-viewer.tsx:
       - Client component for interactive log viewing
       - Time range selector (last 1h, 6h, 24h, 7d)
       - Filter input for searching logs
       - Virtual scrolling or pagination for large log sets
       - Log entries: timestamp, message, level (color coded)
       - Auto-refresh toggle (poll every 5s when enabled)

    4. Create dashboard/components/logs/error-summary.tsx:
       - Display error aggregation as cards or bar chart
       - Show top 10 error types with counts
       - Click error type to filter logs

    5. Create dashboard/app/(dashboard)/sites/[siteId]/logs/page.tsx:
       - Server component that fetches initial logs
       - Pass log group name: /aws/lambda/{functionName}
       - Get function name from ProjectsTable metadata (serverFunctionName field)
       - Render LogViewer and ErrorSummary components

       The function name is stored in ProjectsTable during deployment. Add a getProjectDetails function to dynamodb.ts:
       ```typescript
       export async function getProjectDetails(projectId: string) {
         const command = new GetCommand({
           TableName: process.env.PROJECTS_TABLE_NAME,
           Key: { projectId },
         });
         const result = await dynamodb.send(command);
         return result.Item as Project | undefined;
       }
       ```

       Then in the page:
       ```typescript
       const project = await getProjectDetails(params.siteId);
       const logGroupName = `/aws/lambda/${project?.serverFunctionName}`;
       ```

       IMPORTANT: This assumes Phase 2 deploy-handler stores serverFunctionName in ProjectsTable.
       If not already stored, add serverFunctionName and serverFunctionArn fields to project
       schema and update deploy-handler to write them during deployment.
  </action>
  <verify>
    1. Navigate to /sites/[siteId]/logs
    2. See recent logs displayed
    3. Change time range - logs update
    4. Enter filter text - logs filtered
    5. Error summary shows aggregated error types
  </verify>
  <done>Logs page displays runtime logs with filtering, time range selection, and error aggregation summary.</done>
</task>

<task type="auto">
  <name>Task 2: Build Metrics Dashboard with Recharts</name>
  <files>
    dashboard/lib/aws/cloudwatch.ts
    dashboard/app/(dashboard)/sites/[siteId]/metrics/page.tsx
    dashboard/components/charts/metrics-chart.tsx
    dashboard/components/charts/stats-cards.tsx
  </files>
  <action>
    1. Install Recharts and CloudWatch SDK:
       ```bash
       cd /Users/myownip/workspace/vercel-clone/dashboard
       npm install recharts @aws-sdk/client-cloudwatch
       ```

    2. Create dashboard/lib/aws/cloudwatch.ts:
       ```typescript
       import { CloudWatchClient, GetMetricDataCommand } from '@aws-sdk/client-cloudwatch';

       const cloudwatch = new CloudWatchClient({ region: process.env.AWS_REGION });

       export async function getLambdaMetrics(functionName: string, hours: number = 24) {
         const endTime = new Date();
         const startTime = new Date(endTime.getTime() - hours * 60 * 60 * 1000);
         const period = hours <= 6 ? 60 : hours <= 24 ? 300 : 3600; // 1min, 5min, or 1hour

         const command = new GetMetricDataCommand({
           MetricDataQueries: [
             {
               Id: 'invocations',
               MetricStat: {
                 Metric: {
                   Namespace: 'AWS/Lambda',
                   MetricName: 'Invocations',
                   Dimensions: [{ Name: 'FunctionName', Value: functionName }],
                 },
                 Period: period,
                 Stat: 'Sum',
               },
             },
             {
               Id: 'errors',
               MetricStat: {
                 Metric: {
                   Namespace: 'AWS/Lambda',
                   MetricName: 'Errors',
                   Dimensions: [{ Name: 'FunctionName', Value: functionName }],
                 },
                 Period: period,
                 Stat: 'Sum',
               },
             },
             {
               Id: 'duration_p50',
               MetricStat: {
                 Metric: {
                   Namespace: 'AWS/Lambda',
                   MetricName: 'Duration',
                   Dimensions: [{ Name: 'FunctionName', Value: functionName }],
                 },
                 Period: period,
                 Stat: 'p50',
               },
             },
             {
               Id: 'duration_p95',
               MetricStat: {
                 Metric: {
                   Namespace: 'AWS/Lambda',
                   MetricName: 'Duration',
                   Dimensions: [{ Name: 'FunctionName', Value: functionName }],
                 },
                 Period: period,
                 Stat: 'p95',
               },
             },
             {
               Id: 'duration_p99',
               MetricStat: {
                 Metric: {
                   Namespace: 'AWS/Lambda',
                   MetricName: 'Duration',
                   Dimensions: [{ Name: 'FunctionName', Value: functionName }],
                 },
                 Period: period,
                 Stat: 'p99',
               },
             },
           ],
           StartTime: startTime,
           EndTime: endTime,
         });

         const response = await cloudwatch.send(command);
         return response.MetricDataResults || [];
       }
       ```

    3. Create dashboard/components/charts/stats-cards.tsx:
       - Display summary cards: Total Requests, Error Rate, Avg Response Time
       - Calculate from metrics data
       - Color code: green for low error rate, yellow for medium, red for high

    4. Create dashboard/components/charts/metrics-chart.tsx:
       - Client component ('use client') for Recharts
       - ResponsiveContainer + LineChart
       - Two charts:
         a) Invocations & Errors over time (dual Y-axis or stacked)
         b) Duration percentiles (p50, p95, p99) over time
       - Tooltip with formatted values
       - Legend for multiple lines

    5. Create dashboard/app/(dashboard)/sites/[siteId]/metrics/page.tsx:
       - Server component fetches metrics
       - Time range selector (6h, 24h, 7d, 30d)
       - Render StatsCards at top
       - Render MetricsChart below
       - Handle case where no metrics data (new site)
  </action>
  <verify>
    1. Navigate to /sites/[siteId]/metrics
    2. See stats cards (may show 0 if no traffic)
    3. See line charts for invocations/errors and duration
    4. Change time range - charts update
    5. Hover on chart - see tooltip with values
  </verify>
  <done>Metrics page shows invocations, errors, and response time percentiles with interactive charts.</done>
</task>

<task type="auto">
  <name>Task 3: Build Cost Breakdown Page</name>
  <files>
    dashboard/lib/aws/cost-explorer.ts
    dashboard/app/(dashboard)/sites/[siteId]/costs/page.tsx
    dashboard/components/charts/cost-breakdown.tsx
    dashboard/components/charts/cost-trend.tsx
  </files>
  <action>
    1. Install Cost Explorer SDK:
       ```bash
       cd /Users/myownip/workspace/vercel-clone/dashboard
       npm install @aws-sdk/client-cost-explorer
       ```

    2. Create dashboard/lib/aws/cost-explorer.ts:
       ```typescript
       import { CostExplorerClient, GetCostAndUsageCommand } from '@aws-sdk/client-cost-explorer';

       // Cost Explorer API is only in us-east-1
       const ce = new CostExplorerClient({ region: 'us-east-1' });

       export async function getCostBreakdown(projectId: string, days: number = 30) {
         const endDate = new Date();
         const startDate = new Date(endDate.getTime() - days * 24 * 60 * 60 * 1000);

         const formatDate = (d: Date) => d.toISOString().split('T')[0];

         const command = new GetCostAndUsageCommand({
           TimePeriod: {
             Start: formatDate(startDate),
             End: formatDate(endDate),
           },
           Granularity: 'DAILY',
           Metrics: ['UnblendedCost'],
           GroupBy: [
             { Type: 'DIMENSION', Key: 'SERVICE' },
           ],
           Filter: {
             Tags: {
               Key: 'ProjectId',
               Values: [projectId],
             },
           },
         });

         try {
           const response = await ce.send(command);
           return response.ResultsByTime || [];
         } catch (error) {
           // Cost Explorer may not have data for new projects
           console.error('Cost Explorer error:', error);
           return [];
         }
       }

       export async function getTotalCost(projectId: string, days: number = 30) {
         const results = await getCostBreakdown(projectId, days);

         let total = 0;
         const byService: Record<string, number> = {};

         for (const day of results) {
           for (const group of day.Groups || []) {
             const service = group.Keys?.[0] || 'Other';
             const amount = parseFloat(group.Metrics?.UnblendedCost?.Amount || '0');
             total += amount;
             byService[service] = (byService[service] || 0) + amount;
           }
         }

         return { total, byService };
       }
       ```

    3. Create dashboard/components/charts/cost-breakdown.tsx:
       - Pie or bar chart showing cost by service
       - Services: Lambda, CloudFront, S3, DynamoDB, etc.
       - Show percentages and absolute values
       - Total cost displayed prominently

    4. Create dashboard/components/charts/cost-trend.tsx:
       - Line chart showing daily cost over time
       - Stacked area chart by service (optional)
       - Helps identify cost spikes

    5. Create dashboard/app/(dashboard)/sites/[siteId]/costs/page.tsx:
       - Server component fetches cost data
       - Handle empty state (new project, no cost data yet)
       - Show warning about 24-48 hour data lag
       - Time range selector (7d, 30d, 90d)
       - Render CostBreakdown and CostTrend charts

    6. Add costs link to site navigation (dashboard/components/dashboard/site-nav.tsx).

    IMPORTANT: Cost Explorer costs $0.01 per API request. Add caching:
    - Use unstable_cache from next/cache with 24-hour revalidation
    - Or implement simple in-memory cache

    ```typescript
    import { unstable_cache } from 'next/cache';

    export const getCachedCostBreakdown = unstable_cache(
      async (projectId: string, days: number) => getCostBreakdown(projectId, days),
      ['cost-breakdown'],
      { revalidate: 86400 } // 24 hours
    );
    ```
  </action>
  <verify>
    1. Navigate to /sites/[siteId]/costs
    2. See cost breakdown by service (may be empty for new projects)
    3. See daily cost trend chart
    4. See total cost for period
    5. Change time range - data updates
    6. Data lag warning displayed
  </verify>
  <done>Cost breakdown page shows AWS costs by service with daily trend, cached for 24 hours.</done>
</task>

</tasks>

<verification>
1. `cd dashboard && npm run build` - builds without errors
2. Logs Page (/sites/[siteId]/logs):
   - Displays runtime logs from Lambda
   - Time range filtering works
   - Text filter works
   - Error aggregation shows error types and counts
3. Metrics Page (/sites/[siteId]/metrics):
   - Stats cards show totals
   - Invocations/Errors chart renders
   - Duration percentiles chart renders
   - Time range changes update charts
4. Costs Page (/sites/[siteId]/costs):
   - Cost breakdown by service displays
   - Daily cost trend displays
   - Handles empty state gracefully
   - Data lag warning shown
</verification>

<success_criteria>
- Logs page at /sites/[siteId]/logs with runtime log viewer
- Error aggregation shows top 10 error types
- Metrics page at /sites/[siteId]/metrics with Recharts visualizations
- Invocations, errors, p50/p95/p99 duration displayed
- Cost page at /sites/[siteId]/costs with service breakdown
- Cost Explorer data cached for 24 hours
- All pages handle empty/error states gracefully
- Site navigation includes all observability links
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-observability/03-04-SUMMARY.md`
</output>
