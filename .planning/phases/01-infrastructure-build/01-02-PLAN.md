---
phase: 01-infrastructure-build
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - infra/webhooks.ts
  - packages/functions/webhook-handler/index.ts
  - packages/core/schemas/webhook.ts
  - sst.config.ts
autonomous: true

must_haves:
  truths:
    - "GitHub webhook receives push events to public API endpoint"
    - "Webhook signature validation rejects invalid requests (401)"
    - "Valid webhook creates deployment record with status 'queued'"
    - "Webhook returns 202 Accepted immediately (< 1 second)"
  artifacts:
    - path: "infra/webhooks.ts"
      provides: "API Gateway endpoint with webhook Lambda integration"
      exports: ["webhookApi"]
    - path: "packages/functions/webhook-handler/index.ts"
      provides: "GitHub webhook validation and deployment creation"
      exports: ["handler"]
    - path: "packages/core/schemas/webhook.ts"
      provides: "Zod schema for GitHub push payload validation"
      exports: ["GitHubPushPayloadSchema"]
  key_links:
    - from: "packages/functions/webhook-handler/index.ts"
      to: "GitHub signature validation"
      via: "crypto.timingSafeEqual HMAC comparison"
      pattern: "timingSafeEqual"
    - from: "packages/functions/webhook-handler/index.ts"
      to: "packages/core/db/deployments.ts"
      via: "createDeployment function call"
      pattern: "createDeployment"
    - from: "infra/webhooks.ts"
      to: "API Gateway"
      via: "POST /webhook/{projectId} route"
      pattern: "POST.*webhook"
---

<objective>
Create secure GitHub webhook integration with HMAC signature validation, immediate 202 response, and deployment record creation.

Purpose: Enable GitHub to trigger builds on push to main branch. Validates webhook authenticity to prevent security vulnerabilities, creates deployment record immediately, and returns before long-running build starts (async pattern).

Output: Public API endpoint accepting GitHub webhooks, Lambda handler with signature validation, deployment records created in DynamoDB with "queued" status ready for build pipeline.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-build/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create webhook API Gateway infrastructure</name>
  <files>
    infra/webhooks.ts
  </files>
  <action>
    Create infra/webhooks.ts with SST Api component:

    **API Gateway configuration:**
    - Route: POST /webhook/{projectId}
    - Handler: packages/functions/webhook-handler
    - Timeout: 30 seconds (API Gateway max is 29s, handler must return in < 1s)
    - Environment variables:
      - PROJECTS_TABLE: Link to DynamoDB projects table
      - DEPLOYMENTS_TABLE: Link to DynamoDB deployments table
      - WEBHOOK_SECRET: SST Secret for GitHub webhook secret
    - IAM permissions:
      - DynamoDB: GetItem, PutItem on both tables
      - Secrets Manager: GetSecretValue (for webhook secret)

    Use SST Function component with link to database tables (automatic IAM policy creation).

    Reference Research Pattern 3 for async webhook pattern.

    Critical: Handler MUST return in < 1 second (202 Accepted). Actual build processing happens asynchronously in Plan 03 (SQS queue).
  </action>
  <verify>
    ```bash
    cat infra/webhooks.ts | grep "POST.*webhook"
    cat infra/webhooks.ts | grep "WEBHOOK_SECRET"
    ```
  </verify>
  <done>
    API Gateway defined with POST /webhook/{projectId} route, Lambda handler linked, environment variables configured
  </done>
</task>

<task type="auto">
  <name>Create GitHub webhook payload validation schema</name>
  <files>
    packages/core/schemas/webhook.ts
  </files>
  <action>
    Create Zod schema for GitHub push webhook payload:

    ```typescript
    import { z } from 'zod';

    export const GitHubPushPayloadSchema = z.object({
      ref: z.string(), // e.g., "refs/heads/main"
      repository: z.object({
        full_name: z.string(),
        clone_url: z.string().url(),
      }),
      after: z.string(), // commit SHA
      head_commit: z.object({
        id: z.string(),
        message: z.string(),
        timestamp: z.string(),
        author: z.object({
          name: z.string(),
          email: z.string().email(),
        }),
      }).nullable(), // Can be null for deleted branches
    });

    export type GitHubPushPayload = z.infer<typeof GitHubPushPayloadSchema>;
    ```

    Schema validates all fields used by webhook handler (ref for branch filtering, clone_url for build, after for commit SHA, head_commit for metadata).

    Reference GitHub webhook documentation for payload structure: https://docs.github.com/en/webhooks/webhook-events-and-payloads#push
  </action>
  <verify>
    ```bash
    cat packages/core/schemas/webhook.ts | grep "GitHubPushPayloadSchema"
    ```
  </verify>
  <done>
    Zod schema validates GitHub push payload structure with required fields
  </done>
</task>

<task type="auto">
  <name>Implement webhook handler with signature validation</name>
  <files>
    packages/functions/webhook-handler/index.ts
  </files>
  <action>
    Create Lambda handler in packages/functions/webhook-handler/index.ts:

    **Implementation steps:**

    1. **Validate signature** (Security Critical - Research Pitfall 6):
       - Extract x-hub-signature-256 header
       - Retrieve WEBHOOK_SECRET from environment
       - Compute HMAC-SHA256 of request body
       - Use crypto.timingSafeEqual for comparison (prevents timing attacks)
       - Return 401 if signature invalid

    2. **Parse and validate payload**:
       - Parse JSON body
       - Validate with GitHubPushPayloadSchema
       - Return 400 if validation fails

    3. **Filter branch**:
       - Only process ref === "refs/heads/main"
       - Return 200 for other branches (acknowledged but ignored)

    4. **Verify project exists**:
       - Extract projectId from path parameters
       - Call getProject(projectId) from data access layer
       - Return 404 if project not found

    5. **Create deployment record**:
       - Generate deploymentId with nanoid()
       - Call createDeployment with:
         - projectId from path parameter
         - userId from project record
         - commitSha from payload.after
         - status: "queued"
         - metadata: commit message, author
       - Store in DynamoDB

    6. **Return immediately**:
       - Return 202 Accepted with deploymentId
       - Do NOT wait for build (async pattern)

    Reference Research Example 3 for signature validation code pattern.

    Critical security requirements:
    - MUST use crypto.timingSafeEqual (not === comparison)
    - MUST validate signature BEFORE processing payload
    - MUST log signature validation failures for monitoring

    Why 202 Accepted: API Gateway has 29-second timeout (Research Pitfall 3). Build takes minutes. Returning immediately with job ID allows client to poll status separately.
  </action>
  <verify>
    ```bash
    grep "timingSafeEqual" packages/functions/webhook-handler/index.ts
    grep "createDeployment" packages/functions/webhook-handler/index.ts
    grep "202" packages/functions/webhook-handler/index.ts
    ```
  </verify>
  <done>
    Webhook handler validates signatures with timing-safe comparison, creates deployment record, returns 202 within 1 second
  </done>
</task>

<task type="auto">
  <name>Wire webhook infrastructure and test with mock payload</name>
  <files>
    sst.config.ts
    test-webhook.sh
  </files>
  <action>
    Update sst.config.ts to deploy webhook API:

    ```typescript
    import { webhooks } from "./infra/webhooks";

    // In run() function:
    const { webhookApi } = await webhooks({
      projectsTable,
      deploymentsTable,
    });

    return {
      // ... existing outputs
      webhookUrl: webhookApi.url,
    };
    ```

    Create SST Secret for webhook secret:

    ```bash
    npx sst secret set WEBHOOK_SECRET "test-secret-$(openssl rand -hex 32)" --stage dev
    ```

    Deploy updated infrastructure:

    ```bash
    npx sst deploy --stage dev
    ```

    Create test-webhook.sh to test signature validation:

    ```bash
    #!/bin/bash
    WEBHOOK_URL="[from sst deploy output]"
    SECRET="[WEBHOOK_SECRET value]"
    PAYLOAD='{"ref":"refs/heads/main","repository":{"full_name":"test/repo","clone_url":"https://github.com/test/repo"},"after":"abc123","head_commit":{"id":"abc123","message":"test","timestamp":"2026-02-01T00:00:00Z","author":{"name":"Test","email":"test@example.com"}}}'

    SIGNATURE="sha256=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$SECRET" | sed 's/^.* //')"

    # Test valid signature
    curl -X POST "$WEBHOOK_URL/webhook/test-project" \
      -H "Content-Type: application/json" \
      -H "X-Hub-Signature-256: $SIGNATURE" \
      -d "$PAYLOAD"

    # Test invalid signature (should return 401)
    curl -X POST "$WEBHOOK_URL/webhook/test-project" \
      -H "Content-Type: application/json" \
      -H "X-Hub-Signature-256: sha256=invalid" \
      -d "$PAYLOAD"
    ```

    Run test script and verify:
    - Valid signature returns 202 (or 404 if project doesn't exist - expected)
    - Invalid signature returns 401
    - Response time < 1 second

    Note: Full end-to-end test requires project creation (Plan 01 data access layer). This test verifies signature validation works.
  </action>
  <verify>
    ```bash
    npx sst deploy --stage dev
    bash test-webhook.sh
    ```
  </verify>
  <done>
    Webhook API deployed, signature validation rejects invalid requests with 401, valid requests return 202, response time < 1s
  </done>
</task>

</tasks>

<verification>
Run these checks after task completion:

1. API Gateway endpoint exists: Check sst deploy output for webhookUrl
2. Lambda handler deployed: `aws lambda list-functions --region ap-southeast-1 | grep webhook`
3. Signature validation works:
   - Invalid signature returns 401
   - Valid signature returns 202 (or 404 if project not found)
4. Response time < 1 second: Check curl timing or CloudWatch Logs
5. Environment variables set: Check Lambda configuration for PROJECTS_TABLE, DEPLOYMENTS_TABLE, WEBHOOK_SECRET
6. IAM permissions: Lambda can read Projects table and write to Deployments table
</verification>

<success_criteria>
- API Gateway POST /webhook/{projectId} endpoint deployed
- Lambda handler validates GitHub HMAC-SHA256 signatures with timing-safe comparison
- Invalid signatures rejected with 401 Unauthorized
- Valid webhooks for main branch create deployment record with status "queued"
- Handler returns 202 Accepted in < 1 second (async pattern)
- Webhook secret stored in SST Secrets (not hardcoded)
- Non-main branch pushes acknowledged but not processed (200 OK)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-build/01-02-SUMMARY.md`
</output>
