---
phase: 01-infrastructure-build
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - sst.config.ts
  - infra/database.ts
  - infra/storage.ts
  - packages/core/schemas/project.ts
  - packages/core/schemas/deployment.ts
  - packages/core/db/index.ts
autonomous: true

must_haves:
  truths:
    - "DynamoDB tables exist with multi-tenant isolation (userId GSI)"
    - "S3 buckets exist with lifecycle policies configured"
    - "SST infrastructure can be deployed to AWS Singapore region"
  artifacts:
    - path: "sst.config.ts"
      provides: "SST Ion v3 configuration with app name and region"
      min_lines: 20
    - path: "infra/database.ts"
      provides: "DynamoDB table definitions with tenant isolation"
      exports: ["projectsTable", "deploymentsTable"]
    - path: "infra/storage.ts"
      provides: "S3 bucket configurations with lifecycle policies"
      exports: ["artifactsBucket", "logsBucket"]
    - path: "packages/core/schemas/project.ts"
      provides: "Zod schemas for project validation"
      exports: ["ProjectSchema", "CreateProjectSchema"]
    - path: "packages/core/db/index.ts"
      provides: "DynamoDB data access layer with tenant filtering"
      exports: ["getProject", "listUserProjects", "createProject", "updateDeployment", "listProjectDeployments"]
  key_links:
    - from: "sst.config.ts"
      to: "infra/database.ts"
      via: "imports and runs database infrastructure"
      pattern: "import.*database"
    - from: "packages/core/db/index.ts"
      to: "DynamoDB"
      via: "AWS SDK v3 client with userId filtering"
      pattern: "userId.*=.*:userId"
    - from: "infra/storage.ts"
      to: "S3"
      via: "lifecycle policies with 90-day retention"
      pattern: "expiration.*days.*90"
---

<objective>
Establish foundational AWS infrastructure using SST Ion v3 with multi-tenant DynamoDB tables, S3 storage with lifecycle policies, and TypeScript data access layer.

Purpose: Create the data persistence and storage foundation that all subsequent plans depend on. Implements row-level security for multi-tenant isolation and lifecycle policies to prevent cost balloon.

Output: Deployable SST infrastructure with DynamoDB tables (Projects, Deployments), S3 buckets (artifacts, logs), and typed data access layer ready for use by webhook and build pipeline.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-build/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Initialize SST Ion v3 project with TypeScript</name>
  <files>
    package.json
    sst.config.ts
    tsconfig.json
    .gitignore
  </files>
  <action>
    Initialize Node.js project and install SST Ion v3 with dependencies:

    ```bash
    npm init -y
    npm install sst@latest
    npm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb @aws-sdk/client-s3
    npm install zod nanoid
    npm install -D typescript @types/node @types/aws-lambda
    npx tsc --init
    ```

    Create sst.config.ts:
    - App name: "anchor-deploy"
    - Region: ap-southeast-1 (AWS Singapore)
    - Removal policy: retain for production, remove for non-prod
    - Use TypeScript configuration format

    Update .gitignore:
    - Add node_modules, .sst, .env, .DS_Store
    - Keep .planning/ tracked (not ignored)

    Critical: Configure AWS region to ap-southeast-1 (Singapore) as per PROJECT.md constraint.
  </action>
  <verify>
    ```bash
    cat sst.config.ts | grep "ap-southeast-1"
    npm list sst
    ```
  </verify>
  <done>
    sst.config.ts exists with Singapore region configured, all dependencies installed, TypeScript configured
  </done>
</task>

<task type="auto">
  <name>Create DynamoDB tables with multi-tenant isolation</name>
  <files>
    infra/database.ts
    packages/core/schemas/project.ts
    packages/core/schemas/deployment.ts
  </files>
  <action>
    Create infra/database.ts with SST Dynamo component:

    Single-table design with row-level security (Research Decision 1):

    **Projects Table:**
    - Primary Key: PK (projectId), SK (METADATA)
    - GSI: UserIdIndex on userId (enables "all projects for user" query)
    - Attributes: userId, projectId, name, repoUrl, branch, createdAt
    - Billing mode: ON_DEMAND (not provisioned - usage too low per Research)

    **Deployments Table:**
    - Primary Key: PK (projectId), SK (DEPLOYMENT#{timestamp}#{deploymentId})
    - GSI: DeploymentIdIndex on deploymentId (enables lookup by deploymentId)
    - Attributes: deploymentId, projectId, userId, commitSha, status, createdAt
    - Billing mode: ON_DEMAND

    Create Zod schemas in packages/core/schemas/:
    - project.ts: ProjectSchema, CreateProjectSchema with validation (name 3-50 chars, valid URL)
    - deployment.ts: DeploymentSchema, CreateDeploymentSchema with status enum

    Reference Research Example 1 for DynamoDB schema patterns.

    Critical: Every table MUST have userId for tenant isolation. GSI on userId is mandatory for efficient filtering.
  </action>
  <verify>
    ```bash
    grep -r "userId" infra/database.ts
    cat packages/core/schemas/project.ts | grep "z.object"
    ```
  </verify>
  <done>
    DynamoDB tables defined with userId GSI, Zod schemas validate all required fields, ready for SST deployment
  </done>
</task>

<task type="auto">
  <name>Create S3 buckets with lifecycle policies</name>
  <files>
    infra/storage.ts
  </files>
  <action>
    Create infra/storage.ts with SST Bucket component:

    **Artifacts Bucket:**
    - Name: anchor-deploy-artifacts
    - Lifecycle policy: Delete after 90 days (Research Decision 2 - hybrid retention)
    - Prefix: artifacts/ for build outputs
    - Versioning: disabled (artifacts are immutable by deploymentId)

    **Logs Bucket:**
    - Name: anchor-deploy-logs
    - Lifecycle policy:
      - Transition to GLACIER after 30 days
      - Transition to DEEP_ARCHIVE after 365 days
    - Prefix: logs/ for build logs

    Reference Research Pattern 4 for S3 lifecycle configuration.

    Critical: Lifecycle policies MUST be configured at bucket creation. Cannot be retroactively applied to reduce costs on existing data. This prevents silent cost balloon (Research Pitfall 5).

    Do NOT create separate buckets per project (multi-bucket anti-pattern). Use single buckets with projectId prefixes.
  </action>
  <verify>
    ```bash
    cat infra/storage.ts | grep "expiration"
    cat infra/storage.ts | grep "GLACIER"
    ```
  </verify>
  <done>
    S3 buckets defined with lifecycle policies (90-day artifacts, 30-day â†’ Glacier logs), ready for SST deployment
  </done>
</task>

<task type="auto">
  <name>Create TypeScript data access layer with tenant isolation</name>
  <files>
    packages/core/db/index.ts
    packages/core/db/projects.ts
    packages/core/db/deployments.ts
  </files>
  <action>
    Create typed data access layer in packages/core/db/:

    **projects.ts:**
    - getProject(projectId, userId): Verify ownership via userId condition
    - listUserProjects(userId): Query UserIdIndex GSI
    - createProject(userId, data): Validate with ProjectSchema, generate projectId with nanoid
    - updateProject(projectId, userId, data): Update with userId condition

    **deployments.ts:**
    - createDeployment(projectId, userId, commitSha, metadata): Generate deploymentId, set status to "queued", store commit message
    - getDeployment(deploymentId): Query DeploymentIdIndex GSI
    - listProjectDeployments(projectId, userId): Verify project ownership first, then query deployments (returns commitSha, message, status)
    - updateDeploymentStatus(deploymentId, status): Update status field
    - updateDeployment(deploymentId, fields): Update arbitrary fields (buildId, endedAt, error, etc.) - used by build orchestrator

    **index.ts:**
    - Export all functions from projects.ts and deployments.ts
    - Configure DynamoDB client with region ap-southeast-1

    Reference Research Example 1 for multi-tenant query patterns.

    Critical: EVERY query MUST filter by userId (row-level security). Never use scan() without userId filter. Use KeyConditionExpression with userId in GSI queries.

    Use Zod schemas for runtime validation before DynamoDB operations.
  </action>
  <verify>
    ```bash
    grep -r "userId.*:userId" packages/core/db/
    cat packages/core/db/index.ts | grep "export"
    ```
  </verify>
  <done>
    Data access layer enforces userId filtering on all queries, exports typed functions, ready for use by Lambda handlers
  </done>
</task>

<task type="auto">
  <name>Wire infrastructure in sst.config.ts and test deployment</name>
  <files>
    sst.config.ts
  </files>
  <action>
    Update sst.config.ts to import and deploy all infrastructure:

    ```typescript
    import { database } from "./infra/database";
    import { storage } from "./infra/storage";

    export default $config({
      app(input) {
        return {
          name: "anchor-deploy",
          removal: input?.stage === "production" ? "retain" : "remove",
          home: "aws",
        };
      },
      async run() {
        const region = "ap-southeast-1";

        // Deploy database tables
        const { projectsTable, deploymentsTable } = await database();

        // Deploy storage buckets
        const { artifactsBucket, logsBucket } = await storage();

        return {
          region,
          projectsTable: projectsTable.name,
          deploymentsTable: deploymentsTable.name,
          artifactsBucket: artifactsBucket.name,
          logsBucket: logsBucket.name,
        };
      }
    });
    ```

    Test deployment to dev stage:

    ```bash
    npx sst deploy --stage dev
    ```

    Verify resources created in AWS Console:
    - DynamoDB tables exist with correct GSI
    - S3 buckets exist with lifecycle policies
    - Region is ap-southeast-1

    If deployment fails, check AWS credentials configured via `aws configure`.
  </action>
  <verify>
    ```bash
    npx sst deploy --stage dev
    aws dynamodb list-tables --region ap-southeast-1 | grep anchor-deploy
    aws s3 ls | grep anchor-deploy
    ```
  </verify>
  <done>
    SST infrastructure deploys successfully to AWS Singapore, DynamoDB tables and S3 buckets exist, outputs show resource names
  </done>
</task>

</tasks>

<verification>
Run these checks after task completion:

1. SST deployment succeeds: `npx sst deploy --stage dev`
2. DynamoDB tables exist: `aws dynamodb describe-table --table-name [ProjectsTableName] --region ap-southeast-1`
3. Tables have userId GSI: Check IndexName in describe-table output
4. S3 buckets exist: `aws s3 ls`
5. Lifecycle policies configured: `aws s3api get-bucket-lifecycle-configuration --bucket [BucketName]`
6. TypeScript compiles: `npx tsc --noEmit`
7. Data access functions type-check correctly
</verification>

<success_criteria>
- SST Ion v3 project initialized with TypeScript
- DynamoDB tables (Projects, Deployments) deployed with userId GSI
- S3 buckets (artifacts, logs) deployed with lifecycle policies
- Region configured to ap-southeast-1 (Singapore)
- Zod schemas validate project and deployment data
- Data access layer enforces userId filtering on all queries
- `npx sst deploy` succeeds and outputs resource names
- AWS Console shows resources in Singapore region
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-build/01-01-SUMMARY.md`
</output>
