---
phase: 01-infrastructure-build
plan: 04
type: execute
wave: 3
depends_on: [01-03]
files_modified:
  - packages/core/db/deployments.ts
  - packages/functions/build-orchestrator/index.ts
  - infra/webhooks.ts
  - buildspecs/nextjs-build.yml
autonomous: true

must_haves:
  truths:
    - "User can configure environment variables per project"
    - "Environment variables injected into CodeBuild during build"
    - "Build logs streamed to CloudWatch and accessible via API"
    - "User can view real-time build progress"
  artifacts:
    - path: "packages/core/db/deployments.ts"
      provides: "Environment variables storage and retrieval"
      exports: ["setProjectEnvVars", "getProjectEnvVars"]
    - path: "packages/functions/build-orchestrator/index.ts"
      provides: "Env vars passed to CodeBuild"
      contains: "environmentVariablesOverride"
    - path: "infra/webhooks.ts"
      provides: "API endpoints for env vars and logs"
      exports: ["GET /projects/{id}/env", "PUT /projects/{id}/env", "GET /deployments/{id}/logs"]
  key_links:
    - from: "packages/core/db/deployments.ts"
      to: "DynamoDB Projects table"
      via: "envVars attribute storage"
      pattern: "envVars"
    - from: "packages/functions/build-orchestrator/index.ts"
      to: "CodeBuild"
      via: "environmentVariablesOverride with project env vars"
      pattern: "environmentVariablesOverride"
    - from: "GET /deployments/{id}/logs"
      to: "CloudWatch Logs"
      via: "GetLogEvents API call with buildId"
      pattern: "GetLogEvents"
---

<objective>
Add environment variables configuration and real-time build log streaming to complete Phase 1 requirements.

Purpose: Enable users to configure build-time environment variables (NEXT_PUBLIC_* vars, API URLs) and view real-time build logs during deployment. Completes BUILD-03 and BUILD-05 requirements.

Output: API endpoints to manage project environment variables, build logs accessible via API, environment variables injected into CodeBuild builds.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-build/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Add environment variables storage to Projects table</name>
  <files>
    packages/core/db/projects.ts
    packages/core/schemas/project.ts
  </files>
  <action>
    Extend Projects table schema and data access layer:

    **Update ProjectSchema in packages/core/schemas/project.ts:**

    ```typescript
    export const EnvVarSchema = z.object({
      key: z.string().min(1).regex(/^[A-Z_][A-Z0-9_]*$/, "Must be uppercase with underscores"),
      value: z.string(),
      isSecret: z.boolean().default(false),
    });

    export const ProjectSchema = z.object({
      // ... existing fields
      envVars: z.array(EnvVarSchema).default([]),
    });

    export const UpdateEnvVarsSchema = z.object({
      envVars: z.array(EnvVarSchema),
    });
    ```

    **Add functions to packages/core/db/projects.ts:**

    ```typescript
    export const setProjectEnvVars = async (
      projectId: string,
      userId: string,
      envVars: EnvVar[]
    ): Promise<void> => {
      // Verify project ownership
      await getProject(projectId, userId);

      // Update envVars attribute
      await dynamodb.updateItem({
        TableName: process.env.PROJECTS_TABLE,
        Key: {
          PK: `PROJECT#${projectId}`,
          SK: 'METADATA',
        },
        UpdateExpression: 'SET envVars = :envVars, updatedAt = :updatedAt',
        ConditionExpression: 'userId = :userId',
        ExpressionAttributeValues: {
          ':envVars': envVars,
          ':updatedAt': new Date().toISOString(),
          ':userId': userId,
        },
      });
    };

    export const getProjectEnvVars = async (
      projectId: string,
      userId: string
    ): Promise<EnvVar[]> => {
      const project = await getProject(projectId, userId);
      return project.envVars || [];
    };
    ```

    Storage strategy (Research Decision 3):
    - Build-time env vars (NEXT_PUBLIC_*, API_URL): Store in DynamoDB (fast, cheap)
    - Secrets (API keys): Mark with isSecret flag, later moved to Secrets Manager (Phase 2)

    Critical: Env vars stored per project, not per deployment. All deployments of a project use same env vars unless explicitly overridden.
  </action>
  <verify>
    ```bash
    grep "envVars" packages/core/schemas/project.ts
    grep "setProjectEnvVars" packages/core/db/projects.ts
    ```
  </verify>
  <done>
    Projects table supports envVars array, data access layer provides set/get functions with userId filtering
  </done>
</task>

<task type="auto">
  <name>Update build orchestrator to inject environment variables</name>
  <files>
    packages/functions/build-orchestrator/index.ts
  </files>
  <action>
    Update build orchestrator to fetch and inject project env vars into CodeBuild:

    **Changes to index.ts:**

    1. Import getProject from data access layer
    2. Before triggering CodeBuild:
       ```typescript
       // Fetch project to get env vars
       const project = await getProject(projectId, userId);

       // Prepare environment variables for CodeBuild
       const envVarsOverride = [
         { name: 'PROJECT_ID', value: projectId, type: 'PLAINTEXT' },
         { name: 'REPO_URL', value: repoUrl, type: 'PLAINTEXT' },
         { name: 'COMMIT_SHA', value: commitSha, type: 'PLAINTEXT' },
         { name: 'DEPLOYMENT_ID', value: deploymentId, type: 'PLAINTEXT' },
         { name: 'ARTIFACTS_BUCKET', value: process.env.ARTIFACTS_BUCKET, type: 'PLAINTEXT' },
         { name: 'DEPLOYMENTS_TABLE', value: process.env.DEPLOYMENTS_TABLE, type: 'PLAINTEXT' },
         { name: 'NODE_ENV', value: 'production', type: 'PLAINTEXT' },
         // Add project env vars
         ...project.envVars.map(ev => ({
           name: ev.key,
           value: ev.value,
           type: ev.isSecret ? 'SECRETS_MANAGER' : 'PLAINTEXT',
         })),
       ];
       ```
    3. Pass to StartBuildCommand:
       ```typescript
       await codebuild.send(new StartBuildCommand({
         projectName: 'anchor-deploy-nextjs-build',
         environmentVariablesOverride: envVarsOverride,
       }));
       ```

    This makes env vars available during `next build` phase (for NEXT_PUBLIC_* variables and API URLs).

    Reference Research on environment variables handling: DynamoDB for build-time, Secrets Manager for runtime secrets.

    Critical: NODE_ENV=production MUST be included. CodeBuild doesn't set this by default (Research Pitfall 4).
  </action>
  <verify>
    ```bash
    grep "environmentVariablesOverride" packages/functions/build-orchestrator/index.ts
    grep "NODE_ENV.*production" packages/functions/build-orchestrator/index.ts
    ```
  </verify>
  <done>
    Build orchestrator fetches project env vars and passes to CodeBuild via environmentVariablesOverride
  </done>
</task>

<task type="auto">
  <name>Create API endpoints for environment variables management</name>
  <files>
    infra/webhooks.ts
    packages/functions/env-vars-handler/index.ts
  </files>
  <action>
    Add API routes to infra/webhooks.ts (or create separate infra/api.ts):

    **Routes:**
    - GET /projects/{projectId}/env - Get project environment variables
    - PUT /projects/{projectId}/env - Update project environment variables

    **Handler implementation** in packages/functions/env-vars-handler/index.ts:

    ```typescript
    import { APIGatewayProxyHandler } from 'aws-lambda';
    import { getProjectEnvVars, setProjectEnvVars } from '@core/db/projects';
    import { UpdateEnvVarsSchema } from '@core/schemas/project';

    export const handler: APIGatewayProxyHandler = async (event) => {
      const projectId = event.pathParameters?.projectId;
      const userId = event.requestContext.authorizer?.userId || 'test-user'; // TODO: Auth in Phase 3

      if (event.httpMethod === 'GET') {
        const envVars = await getProjectEnvVars(projectId, userId);
        return {
          statusCode: 200,
          body: JSON.stringify({ envVars }),
        };
      }

      if (event.httpMethod === 'PUT') {
        const body = UpdateEnvVarsSchema.parse(JSON.parse(event.body));
        await setProjectEnvVars(projectId, userId, body.envVars);
        return {
          statusCode: 200,
          body: JSON.stringify({ success: true }),
        };
      }

      return { statusCode: 405, body: 'Method not allowed' };
    };
    ```

    Note: userId hardcoded to 'test-user' for Phase 1. Proper authentication added in Phase 3 (Dashboard).

    This allows users to configure env vars before triggering deployments.
  </action>
  <verify>
    ```bash
    cat infra/webhooks.ts | grep "/projects/{projectId}/env"
    grep "setProjectEnvVars" packages/functions/env-vars-handler/index.ts
    ```
  </verify>
  <done>
    API endpoints exist for getting/setting project environment variables with Zod validation
  </done>
</task>

<task type="auto">
  <name>Create build logs API endpoint with CloudWatch integration</name>
  <files>
    infra/webhooks.ts
    packages/functions/logs-handler/index.ts
  </files>
  <action>
    Add API route to get build logs:

    **Route:**
    - GET /deployments/{deploymentId}/logs - Stream build logs from CloudWatch

    **Handler implementation** in packages/functions/logs-handler/index.ts:

    ```typescript
    import { APIGatewayProxyHandler } from 'aws-lambda';
    import { CloudWatchLogsClient, GetLogEventsCommand } from '@aws-sdk/client-cloudwatch-logs';
    import { getDeployment } from '@core/db/deployments';

    export const handler: APIGatewayProxyHandler = async (event) => {
      const deploymentId = event.pathParameters?.deploymentId;

      // Get deployment to find buildId
      const deployment = await getDeployment(deploymentId);
      if (!deployment.buildId) {
        return {
          statusCode: 404,
          body: JSON.stringify({ error: 'Build not started yet' }),
        };
      }

      // Fetch logs from CloudWatch
      const cwl = new CloudWatchLogsClient({ region: process.env.AWS_REGION });
      const logGroupName = '/aws/codebuild/anchor-deploy-nextjs-build';
      const logStreamName = deployment.buildId; // CodeBuild uses buildId as log stream name

      const response = await cwl.send(new GetLogEventsCommand({
        logGroupName,
        logStreamName,
        startFromHead: true,
        limit: 1000, // Last 1000 log lines
      }));

      const logs = response.events.map(e => ({
        timestamp: e.timestamp,
        message: e.message,
      }));

      return {
        statusCode: 200,
        body: JSON.stringify({ logs }),
      };
    };
    ```

    Install dependency: `npm install @aws-sdk/client-cloudwatch-logs`

    Update Lambda IAM policy to allow:
    - logs:GetLogEvents on /aws/codebuild/anchor-deploy-nextjs-build

    This enables real-time build log viewing (BUILD-03 requirement).

    Note: For true real-time streaming, use WebSockets or Server-Sent Events (Phase 3 enhancement). Phase 1 uses polling.
  </action>
  <verify>
    ```bash
    cat infra/webhooks.ts | grep "/deployments/{deploymentId}/logs"
    grep "GetLogEventsCommand" packages/functions/logs-handler/index.ts
    npm list @aws-sdk/client-cloudwatch-logs
    ```
  </verify>
  <done>
    API endpoint exists to retrieve build logs from CloudWatch, accessible via deployment ID
  </done>
</task>

<task type="auto">
  <name>Test environment variables and logs end-to-end</name>
  <files>
    test-env-vars.sh
  </files>
  <action>
    Deploy updated infrastructure:

    ```bash
    npx sst deploy --stage dev
    ```

    Create test script test-env-vars.sh:

    ```bash
    #!/bin/bash
    API_URL="[from sst deploy output]"
    PROJECT_ID="test-project"

    # Set environment variables
    curl -X PUT "$API_URL/projects/$PROJECT_ID/env" \
      -H "Content-Type: application/json" \
      -d '{
        "envVars": [
          {"key": "NEXT_PUBLIC_API_URL", "value": "https://api.example.com", "isSecret": false},
          {"key": "NEXT_PUBLIC_SITE_NAME", "value": "Test Site", "isSecret": false}
        ]
      }'

    # Get environment variables
    curl "$API_URL/projects/$PROJECT_ID/env"

    # Trigger build (via webhook or SQS)
    # ... webhook test from Plan 02

    # Wait for build to start
    sleep 30

    # Get deployment ID from webhook response
    DEPLOYMENT_ID="[from webhook response]"

    # Fetch build logs
    curl "$API_URL/deployments/$DEPLOYMENT_ID/logs"
    ```

    Run test and verify:
    1. PUT /projects/{id}/env successfully stores env vars
    2. GET /projects/{id}/env returns stored env vars
    3. Build includes env vars in CodeBuild environment (check CodeBuild logs)
    4. GET /deployments/{id}/logs returns build logs from CloudWatch
    5. Env vars accessible during `next build` (check for NEXT_PUBLIC_* in build output)

    Expected results:
    - Env vars stored and retrieved correctly
    - CodeBuild receives env vars via environmentVariablesOverride
    - Build logs accessible within seconds of build start
    - NEXT_PUBLIC_* variables available in Next.js build
  </action>
  <verify>
    ```bash
    npx sst deploy --stage dev
    bash test-env-vars.sh
    ```
  </verify>
  <done>
    Environment variables configurable via API, injected into builds, logs retrievable from CloudWatch
  </done>
</task>

</tasks>

<verification>
Run these checks after task completion:

1. Env vars API endpoints deployed: Check sst deploy output
2. Env vars stored in DynamoDB: `aws dynamodb get-item --table-name [ProjectsTable] --key '{"PK":{"S":"PROJECT#test-project"},"SK":{"S":"METADATA"}}'`
3. Build receives env vars: Check CodeBuild environment variables in build logs
4. Logs API returns data: `curl [API_URL]/deployments/[id]/logs`
5. CloudWatch Logs accessible: `aws logs get-log-events --log-group-name /aws/codebuild/anchor-deploy-nextjs-build --log-stream-name [buildId]`
6. NEXT_PUBLIC_* vars available in build: Check Next.js build output for env var references
</verification>

<success_criteria>
- Users can set/get project environment variables via API
- Environment variables stored in DynamoDB Projects table
- Build orchestrator injects env vars into CodeBuild via environmentVariablesOverride
- Build logs accessible via GET /deployments/{id}/logs endpoint
- Real-time logs retrieved from CloudWatch Logs
- NEXT_PUBLIC_* variables available during next build phase
- NODE_ENV=production set in all builds
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-build/01-04-SUMMARY.md`
</output>
