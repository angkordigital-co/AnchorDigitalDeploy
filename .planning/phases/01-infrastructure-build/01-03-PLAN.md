---
phase: 01-infrastructure-build
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - infra/build-pipeline.ts
  - packages/functions/build-orchestrator/index.ts
  - buildspecs/nextjs-build.yml
  - packages/functions/webhook-handler/index.ts
  - sst.config.ts
autonomous: true

must_haves:
  truths:
    - "Webhook enqueues build job in SQS queue"
    - "Build orchestrator Lambda polls SQS and triggers CodeBuild"
    - "CodeBuild runs npm install and next build with OpenNext packaging"
    - "Build artifacts uploaded to S3 with projectId/commitSha path"
    - "Deployment status updated from 'queued' to 'building' to 'success'/'failed'"
  artifacts:
    - path: "infra/build-pipeline.ts"
      provides: "SQS queue and CodeBuild project configuration"
      exports: ["buildQueue", "codeBuildProject"]
    - path: "packages/functions/build-orchestrator/index.ts"
      provides: "SQS handler that triggers CodeBuild"
      exports: ["handler"]
    - path: "buildspecs/nextjs-build.yml"
      provides: "CodeBuild instructions for OpenNext packaging"
      min_lines: 40
  key_links:
    - from: "packages/functions/webhook-handler/index.ts"
      to: "SQS queue"
      via: "SendMessageCommand after deployment creation"
      pattern: "SendMessageCommand"
    - from: "packages/functions/build-orchestrator/index.ts"
      to: "CodeBuild"
      via: "StartBuildCommand with buildspec"
      pattern: "StartBuildCommand"
    - from: "buildspecs/nextjs-build.yml"
      to: "S3"
      via: "aws s3 cp artifacts upload"
      pattern: "aws s3 cp.*artifacts"
---

<objective>
Implement asynchronous build pipeline using SQS queue, build orchestrator Lambda, and CodeBuild with OpenNext packaging for Next.js applications.

Purpose: Execute Next.js builds in isolated CodeBuild environment with 30-minute timeout, package with OpenNext for Lambda compatibility, and store artifacts in S3. Uses async pattern to avoid API Gateway timeout limitations.

Output: Complete build pipeline from webhook → SQS → CodeBuild → S3 artifacts, with deployment status tracking throughout the process.
</objective>

<execution_context>
@/Users/myownip/.config/claude/get-shit-done/workflows/execute-plan.md
@/Users/myownip/.config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-build/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create SQS queue and CodeBuild project infrastructure</name>
  <files>
    infra/build-pipeline.ts
  </files>
  <action>
    Create infra/build-pipeline.ts with SST Queue and native AWS resources:

    **SQS Queue:**
    - Name: anchor-deploy-build-queue
    - Visibility timeout: 1800 seconds (30 minutes - matches CodeBuild timeout)
    - Message retention: 14 days (AWS max)
    - Dead Letter Queue: Yes, after 3 failed attempts
    - Batch size: 1 (process builds sequentially per Lambda invocation)

    **CodeBuild Project:**
    Use aws.codebuild.Project (native Pulumi resource, SST doesn't have CodeBuild component):

    - Name: anchor-deploy-nextjs-build
    - Environment:
      - Image: aws/codebuild/standard:7.0 (includes Node.js 22)
      - Compute: BUILD_GENERAL1_SMALL (3GB RAM, 2 vCPU - sufficient for Next.js builds)
      - Privileged mode: false (not building Docker images)
    - Timeout: 30 minutes
    - Buildspec: buildspecs/nextjs-build.yml (created in next task)
    - Artifacts: S3 (artifacts bucket from Plan 01)
    - Cache: S3 for node_modules and .next/cache
    - Service role: IAM role with permissions:
      - S3: Read/Write to artifacts bucket
      - Logs: CreateLogGroup, CreateLogStream, PutLogEvents
      - Secrets Manager: GetSecretValue (for GitHub token if needed)

    Reference Research Example 2 for CodeBuild configuration.

    Critical: Use BUILD_GENERAL1_SMALL (not nano). Nano has 1.5GB RAM which is insufficient for Next.js builds (causes OOM errors).

    Cache configuration reduces build time from 5+ minutes to 30-60 seconds on subsequent builds.
  </action>
  <verify>
    ```bash
    cat infra/build-pipeline.ts | grep "codebuild.Project"
    cat infra/build-pipeline.ts | grep "visibilityTimeout.*1800"
    ```
  </verify>
  <done>
    SQS queue and CodeBuild project defined with correct timeouts, compute size, and IAM permissions
  </done>
</task>

<task type="auto">
  <name>Create CodeBuild buildspec for OpenNext packaging</name>
  <files>
    buildspecs/nextjs-build.yml
  </files>
  <action>
    Create buildspecs/nextjs-build.yml following CodeBuild buildspec v0.2 format:

    **Phases:**

    1. **install:**
       - Runtime: nodejs 22
       - Install pnpm globally: `npm install -g pnpm@latest`

    2. **pre_build:**
       - Clone repository: `git clone $REPO_URL app`
       - Checkout commit: `git checkout $COMMIT_SHA`
       - Install dependencies: `pnpm install --frozen-lockfile`

    3. **build:**
       - Set NODE_ENV=production (Critical - Research Pitfall 4)
       - Run build: `pnpm run build`
       - Run OpenNext adapter: `npx open-next@latest build`
       - Output: .open-next/server-function (Lambda code), .open-next/assets (static files)

    4. **post_build:**
       - Package Lambda function: `cd .open-next/server-function && zip -r ../../lambda.zip .`
       - Upload to S3:
         - Lambda zip: `s3://$ARTIFACTS_BUCKET/artifacts/$PROJECT_ID/$COMMIT_SHA/lambda.zip`
         - Static assets: `s3://$ARTIFACTS_BUCKET/static/$PROJECT_ID/$COMMIT_SHA/`
       - Update deployment status to "success" via AWS CLI:
         ```bash
         aws dynamodb update-item \
           --table-name $DEPLOYMENTS_TABLE \
           --key '{"deploymentId":{"S":"'$DEPLOYMENT_ID'"}}' \
           --update-expression "SET #status = :status, completedAt = :completedAt" \
           --expression-attribute-names '{"#status":"status"}' \
           --expression-attribute-values '{":status":{"S":"success"},":completedAt":{"S":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}}'
         ```

    **Environment variables** (passed by build orchestrator):
    - PROJECT_ID, REPO_URL, COMMIT_SHA, DEPLOYMENT_ID
    - ARTIFACTS_BUCKET, DEPLOYMENTS_TABLE
    - NODE_ENV=production (hardcoded in buildspec)

    **Cache:**
    - node_modules/**/*
    - .next/cache/**/*

    Reference Research Example 2 for complete buildspec structure.

    Critical: MUST set NODE_ENV=production. Lambda doesn't set this by default, causing development builds in production (Research Pitfall 4).
  </action>
  <verify>
    ```bash
    cat buildspecs/nextjs-build.yml | grep "NODE_ENV.*production"
    cat buildspecs/nextjs-build.yml | grep "open-next"
    cat buildspecs/nextjs-build.yml | grep "aws s3 cp"
    ```
  </verify>
  <done>
    Buildspec defines complete build process with OpenNext packaging, S3 upload, and deployment status update
  </done>
</task>

<task type="auto">
  <name>Create build orchestrator Lambda to trigger CodeBuild</name>
  <files>
    packages/functions/build-orchestrator/index.ts
  </files>
  <action>
    Create Lambda handler in packages/functions/build-orchestrator/index.ts:

    **Handler implementation:**

    1. **Process SQS message**:
       - Parse message body (contains deploymentId, projectId, commitSha, repoUrl)
       - Validate message structure

    2. **Update deployment status to "building"**:
       - Call updateDeploymentStatus(deploymentId, "building")
       - Record buildStartedAt timestamp

    3. **Trigger CodeBuild**:
       - Import StartBuildCommand from @aws-sdk/client-codebuild
       - Call startBuild with:
         - projectName: "anchor-deploy-nextjs-build"
         - environmentVariablesOverride:
           - PROJECT_ID: projectId
           - REPO_URL: repoUrl
           - COMMIT_SHA: commitSha
           - DEPLOYMENT_ID: deploymentId
           - ARTIFACTS_BUCKET: process.env.ARTIFACTS_BUCKET
           - DEPLOYMENTS_TABLE: process.env.DEPLOYMENTS_TABLE
       - Capture buildId from response

    4. **Store buildId in deployment record**:
       - Update deployment with buildId (for log streaming in Plan 04)

    5. **Handle errors**:
       - If CodeBuild fails to start, update deployment status to "failed"
       - If SQS message processing fails, throw error (message returns to queue)
       - Log all errors for debugging

    **Dependencies:** @aws-sdk/client-codebuild

    Install: `npm install @aws-sdk/client-codebuild`

    Reference Research Pattern 3 for async build pattern.

    Critical: CodeBuild is fire-and-forget. Orchestrator doesn't wait for build completion. Build updates deployment status itself in post_build phase of buildspec.
  </action>
  <verify>
    ```bash
    grep "StartBuildCommand" packages/functions/build-orchestrator/index.ts
    grep "updateDeploymentStatus" packages/functions/build-orchestrator/index.ts
    ```
  </verify>
  <done>
    Build orchestrator processes SQS messages, updates status to "building", triggers CodeBuild with environment variables
  </done>
</task>

<task type="auto">
  <name>Update webhook handler to enqueue build jobs</name>
  <files>
    packages/functions/webhook-handler/index.ts
  </files>
  <action>
    Update webhook handler to send SQS message after creating deployment:

    Add after createDeployment call:

    ```typescript
    import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';

    // After deployment created:
    const sqs = new SQSClient({ region: process.env.AWS_REGION });
    await sqs.send(new SendMessageCommand({
      QueueUrl: process.env.BUILD_QUEUE_URL,
      MessageBody: JSON.stringify({
        deploymentId,
        projectId,
        commitSha: payload.after,
        repoUrl: payload.repository.clone_url,
        branch: project.branch,
      })
    }));
    ```

    Update infra/webhooks.ts to link BUILD_QUEUE_URL environment variable.

    Install dependency: `npm install @aws-sdk/client-sqs`

    This completes the async pattern: webhook → SQS → orchestrator → CodeBuild.

    Why enqueue AFTER creating deployment: If SQS send fails, deployment record still exists with status "queued". User can retry manually later.
  </action>
  <verify>
    ```bash
    grep "SendMessageCommand" packages/functions/webhook-handler/index.ts
    grep "BUILD_QUEUE_URL" infra/webhooks.ts
    ```
  </verify>
  <done>
    Webhook handler enqueues build job in SQS after creating deployment record
  </done>
</task>

<task type="auto">
  <name>Wire build pipeline and test end-to-end build</name>
  <files>
    sst.config.ts
  </files>
  <action>
    Update sst.config.ts to deploy build pipeline:

    ```typescript
    import { buildPipeline } from "./infra/build-pipeline";

    // In run() function:
    const { buildQueue, codeBuildProject } = await buildPipeline({
      artifactsBucket,
      deploymentsTable,
    });

    // Update webhooks to link build queue
    const { webhookApi } = await webhooks({
      projectsTable,
      deploymentsTable,
      buildQueue,
    });
    ```

    Deploy infrastructure:

    ```bash
    npx sst deploy --stage dev
    ```

    Test end-to-end build:

    1. Create test Next.js project in GitHub
    2. Create project record in DynamoDB:
       ```bash
       aws dynamodb put-item --table-name [ProjectsTableName] \
         --item '{"PK":{"S":"PROJECT#test-project"},"SK":{"S":"METADATA"},"userId":{"S":"test-user"},"projectId":{"S":"test-project"},"name":{"S":"Test Project"},"repoUrl":{"S":"https://github.com/[your-test-repo]"},"branch":{"S":"main"}}'
       ```
    3. Manually send SQS message to trigger build:
       ```bash
       aws sqs send-message \
         --queue-url [QueueUrl from output] \
         --message-body '{"deploymentId":"test-deploy","projectId":"test-project","commitSha":"[recent-commit-sha]","repoUrl":"https://github.com/[your-test-repo]","branch":"main"}'
       ```
    4. Monitor CodeBuild console for build execution
    5. Verify artifacts in S3: `aws s3 ls s3://[ArtifactsBucket]/artifacts/test-project/`
    6. Verify deployment status updated: Check DynamoDB Deployments table

    Note: Full GitHub webhook test requires configuring GitHub webhook URL in repository settings. Manual SQS test verifies build pipeline works.

    Expected results:
    - CodeBuild starts within 30 seconds of SQS message
    - Build completes in 2-5 minutes (first build, no cache)
    - Artifacts appear in S3 at artifacts/test-project/[commit-sha]/lambda.zip
    - Deployment status changes: queued → building → success
  </action>
  <verify>
    ```bash
    npx sst deploy --stage dev
    aws codebuild list-projects
    aws s3 ls s3://[ArtifactsBucket]/artifacts/
    ```
  </verify>
  <done>
    Build pipeline deployed, end-to-end test completes successfully with artifacts in S3 and deployment status "success"
  </done>
</task>

</tasks>

<verification>
Run these checks after task completion:

1. SQS queue exists: `aws sqs list-queues | grep build-queue`
2. CodeBuild project exists: `aws codebuild list-projects`
3. Build orchestrator Lambda exists: `aws lambda list-functions | grep build-orchestrator`
4. Webhook handler sends SQS messages: Check Lambda logs after test webhook
5. Build completes successfully: Check CodeBuild logs
6. Artifacts in S3: `aws s3 ls s3://[bucket]/artifacts/test-project/`
7. Deployment status progression: queued → building → success in DynamoDB
8. Build cache works: Second build completes in < 1 minute
</verification>

<success_criteria>
- SQS queue receives build jobs from webhook handler
- Build orchestrator Lambda triggered by SQS messages
- CodeBuild project runs with 30-minute timeout
- Buildspec executes: npm install → next build → OpenNext packaging
- Lambda function code and static assets uploaded to S3
- Deployment status updates throughout: queued → building → success/failed
- Build cache reduces subsequent builds to < 1 minute
- End-to-end test: webhook → SQS → CodeBuild → S3 artifacts completes
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-build/01-03-SUMMARY.md`
</output>
